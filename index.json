[{"categories":["技术"],"content":"以前写用 go 语言主要是为了代替 c 语言写算法。直到最近几年 docker，k8s 等容器化部署方式的普及，java写的服务越发感觉臃肿，因此有计划用go实现服务。 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:0:0","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"使用 go 写服务的原因 以前写的服务大部分是 java 实现的，但是随着容器化部署的普及，Java写的服务越来越大，打包起来也特别麻烦 在封装java服务的image时，需要打包的有 jvm（jar或jdk） tomcat（或jetty等） 服务相关jar包 这几项加起来很容易就能到 200-300M，如果碰上引用较多的巨无霸包，轻松破 400M，即使使用从 java11 开始的特性，只打包用到的模块，占用空间也不小，而且如果使用了 springboot 等全家桶的话配置起来还比较麻烦。 而用golang编译服务的话，只用一个文件即可实现上面3部分的内容，纯服务打包后基本也就 5-6M， 有前端代码的话，前端代码也可以很方便的打包进二进制文件中。 技巧 虽然磁盘占用看似不是十分重要，但是某些无状态的编译发布情况下，每次都要重新编译发布，这时体积小的，结构简单的会更有优势 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:1:0","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"用golang写服务的优点 下面结合我的感受说一下用golang写服务的优点 可使用协程，执行速度快，内存占用小 编译出来的时机器码，发布内容足够小，编译出来的只有一个可执行文件 跨平台编译，甚至直接在 linux 环境中可编译 windows 下可执行的文件 不再依赖其他虚拟机等，部署方便，能很好的配合 k8s、 docker 等发布 资源依赖 github 等，开源组件多 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:2:0","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"缺点 当然用go也是需要一些付出的，使用过程中也有很多感觉相当麻烦的地方 部分语言的设计较为奇怪 可用资源太多导致轮子太多……需要一定的技巧把各种轮子合并在一起 满屏err处理 缺少泛型支持（最新版本已支持） ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:3:0","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"部分使用感受 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:4:0","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"代码结构 golang说简单也简单，但是复杂起来也是真复杂，看 github 上的代码结构，除了都放根目录的，基本上很难找到两个相同结构的代码。这里我基本参考了 golang-standards/project-layout 。这套结构和以前写过的语言有很大不同，例如以功能分文件夹（包），而不是层级。 举例 java 工程中 service，controller 等包结构看不到了，而是纵向拆分到了不同以功能分类的文件夹中。 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:4:1","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"对接口的使用 golang接口感觉设计的特别巧，可以先写实现再写接口，灵活程度极高，使用方式多样。 例如可以把目前使用的库的方法抽象成接口，可以不用实现接口就能直接使用方法，如果某天准备换另一个库，再进行实现。 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:4:2","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"Error及日志记录处理 首先特别吐槽一下 golang 里面 error 的处理方式，一页代码里至少有一半在处理错误。这里我目前也没啥好接口办法。 另一个问题是错误日志的记录，默认的error过于简单，只是个接口，不能记录堆栈信息，我后来用的 juju/errors 可以弥补一些原生err的问题。 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:4:3","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"Rest服务 其实 golang 已经封装了很大一部分功能。建议使用比较小的框架，例如 gin 或 echo等。这些框架只是对golang原生框架的一个封装，都是及其轻量级的。我建议使用 echo，因为gin没有错误的统一处理，在err满天飞的情况下更加显得雪上加霜。而 echo 有相应的错误统一处理，和一些集成在内部的中间件，可以直接用，稍微方便一些。 ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:4:4","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["技术"],"content":"其他 其实能写的还有很多，要睡觉了，下次再说…… ","date":"2022-03-23","objectID":"/2022/03/2022_03_23_java_to_go/:4:5","tags":["golang"],"title":"golang + docker 写服务的部分感受","uri":"/2022/03/2022_03_23_java_to_go/"},{"categories":["旅行"],"content":"今天早上5点就睡不着了，想起临时找个近点的地方转转，然后就去恭王府晒太阳了。 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:0:0","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"1. 感受 天特别好，人特别多，晒得脖子疼，拍了一堆房顶…… ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:1:0","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"2. 过程 一进门先花30块钱租讲解器 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:2:0","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"2.1 入园 今天环境相对比较嘈杂，讲解器有时候听不太清。另外这个讲解器有蜜汁定位，得去四处找能播放出来的地方，有几处没找到怎么触发讲解。 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:2:1","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"2.2 屋顶时间 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:3:0","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"鸱吻 银安殿的鸱吻，不知道什么时候修的，已经很斑驳了 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:3:1","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"垂兽 - 蹲兽 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:3:2","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"其他 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:3:3","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"后罩楼的窗户 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:3:4","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"2.3 室内 这些都是金丝楠木的？？壕 展览的图太多，懒得整理了…… ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:4:0","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"2.4 后花园 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:5:0","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"独乐峰 据说“独”字在最顶上 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:5:1","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"邀月台 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:5:2","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["旅行"],"content":"水边 碰到一只眼神很酷的野鸭 图片太多，费流量，就不往上贴了。 ","date":"2021-06-05","objectID":"/2021/06/2021-06-05-tourism-bj-gongwangfu/:5:3","tags":["生活"],"title":"恭王府-补钙要适量","uri":"/2021/06/2021-06-05-tourism-bj-gongwangfu/"},{"categories":["技术"],"content":"今天下午才说windows下的go语言不能调用 GDAL，晚上回来看一下源码，发现可以在Windows下使用。写下来记录一下。 ","date":"2021-06-02","objectID":"/2021/06/2021-06-02-gdal-in-golang/:0:0","tags":["golang","gdal"],"title":"在 golang 中使用 GDAL（Windows环境）","uri":"/2021/06/2021-06-02-gdal-in-golang/"},{"categories":["技术"],"content":"1. 背景说明 以前都是使用的C++作为开发语言，GDAL开发没问题；但是在Windows环境中验证Kerberos时遇到了问题，暂时没有解决方案。以前用 golang 连接Kerberos验证成功过，于是准备看一下是否Golang能直接使用GDAL。 使用的是 lukeroth/gdal 库 在今天下午看这个工程时，先查看的 issue，搜索Windows，只有几篇提到了，也没明确说可以用。主工程的说明文档中之提到了 Ubuntu 中可以使用。 晚上再看源码时发现了这个工程有 c_windows_amd64.go 这个文件，说明是可以在Windows下使用的。准备编译测试一下。 ","date":"2021-06-02","objectID":"/2021/06/2021-06-02-gdal-in-golang/:1:0","tags":["golang","gdal"],"title":"在 golang 中使用 GDAL（Windows环境）","uri":"/2021/06/2021-06-02-gdal-in-golang/"},{"categories":["技术"],"content":"2. 编译 ","date":"2021-06-02","objectID":"/2021/06/2021-06-02-gdal-in-golang/:2:0","tags":["golang","gdal"],"title":"在 golang 中使用 GDAL（Windows环境）","uri":"/2021/06/2021-06-02-gdal-in-golang/"},{"categories":["技术"],"content":"2.1 mingw64 环境 根据上面那个文档，可以看出这个工程使用了 cgo，依赖于gcc，于是使用了以前搭建的 MSYS2 环境 msys2 安装方式略 直接安装 GDAL： pacman -S mingw-w64-x86_64-gdal ","date":"2021-06-02","objectID":"/2021/06/2021-06-02-gdal-in-golang/:2:1","tags":["golang","gdal"],"title":"在 golang 中使用 GDAL（Windows环境）","uri":"/2021/06/2021-06-02-gdal-in-golang/"},{"categories":["技术"],"content":"2.2 创建测试工程 创建工程略，测试代码如下 package main import ( \"github.com/lukeroth/gdal\" \"log\" ) func main() { ds := gdal.OpenDataSource(\"E:\\\\Data\\\\shjq\\\\sh_wgs84.shp\", 0) defer ds.Destroy() layer := ds.LayerByIndex(0) for{ if feature := layer.NextFeature(); feature != nil{ defer feature.Destroy() geom := feature.Geometry() wkt, err := geom.ToWKT() if err != nil { log.Fatalf(\"to wkt error: %s\", err) } log.Println(wkt) }else { break } } } ","date":"2021-06-02","objectID":"/2021/06/2021-06-02-gdal-in-golang/:2:2","tags":["golang","gdal"],"title":"在 golang 中使用 GDAL（Windows环境）","uri":"/2021/06/2021-06-02-gdal-in-golang/"},{"categories":["技术"],"content":"2.3 编译 直接在命令行运行 go build 会出现找不到 gdal_i 的问题，这时因为在 c_windows_amd64.go 文件中写死了找包的位置，需要修改源码。 这里我直接改的 C:\\Users\\{USER_NAME}\\go\\pkg\\mod\\github.com\\lukeroth\\gdal@v0.0.0-xxxx 里面的 c_windows_amd64.go 第6，7行改成mingw64为基础的路径（这里文件默认是只读，需要在属性里面把只读去掉）。注意把 -lgdal_i 中的 _i 去掉。 /* #cgo windows LDFLAGS: -LD:/msys64/mingw64/lib -lgdal #cgo windows CFLAGS: -ID:/msys64/mingw64/include */ 此时再执行 go build 即可通过 ","date":"2021-06-02","objectID":"/2021/06/2021-06-02-gdal-in-golang/:2:3","tags":["golang","gdal"],"title":"在 golang 中使用 GDAL（Windows环境）","uri":"/2021/06/2021-06-02-gdal-in-golang/"},{"categories":["技术"],"content":"3. 存在问题 使用过程中发现很多问题： 说明中写的是支持 GDAL2，其实使用 GDAL 3 也能正常编译（不知道有没有坑）； 这个工程虽然近期有更新，但是更多的仍然是基于 GDAL 2 的接口，GDAL3中 Dataset 的接口及其不完整，仍然需要使用 DataSource 接口的相关方法； 用msys2中的GDAL依赖过多，需要的 dll 太多太乱，有时间直接用源码最简编译试试； 建议直接改源码的查找路径，我试过把lib文件和include文件夹放到源码中写死的目录下，但是编译失败； 示例太少，需要看源码中资源的释放情况，有的源码中有资源释放，有的需要手动执行释放。 这个工程能不能满足需求还需进一步测试 ","date":"2021-06-02","objectID":"/2021/06/2021-06-02-gdal-in-golang/:3:0","tags":["golang","gdal"],"title":"在 golang 中使用 GDAL（Windows环境）","uri":"/2021/06/2021-06-02-gdal-in-golang/"},{"categories":["技术"],"content":"最近很忙，没空写东西，今天趁着昨晚的 nightly build 还没完成，写点东西，做个小结。 ","date":"2021-04-10","objectID":"/2021/04/2021-04-10-about-cpp/:0:0","tags":["projection"],"title":"吐槽一下最近开发 c++ 的经历","uri":"/2021/04/2021-04-10-about-cpp/"},{"categories":["技术"],"content":"1. 背景 我平时做大数据开发，用 Linux 环境做开发更顺手。最近项目中要维护 Windows 桌面工具，于是借用了一台 Windows 机器做开发测试 …… ","date":"2021-04-10","objectID":"/2021/04/2021-04-10-about-cpp/:1:0","tags":["projection"],"title":"吐槽一下最近开发 c++ 的经历","uri":"/2021/04/2021-04-10-about-cpp/"},{"categories":["技术"],"content":"2. 踩坑实录 ","date":"2021-04-10","objectID":"/2021/04/2021-04-10-about-cpp/:2:0","tags":["projection"],"title":"吐槽一下最近开发 c++ 的经历","uri":"/2021/04/2021-04-10-about-cpp/"},{"categories":["技术"],"content":"2.1. Qt Qt很强大，项目前期都在用qt开发，都可以基本不用stl库的东西。但是开发过程中也有很多我不能理解的坑，估计也是没用熟悉。 2.1.1. 坑1： Model-View-Delegate 模式 用以前开发 Java/.net 等语言的 MVC 或 MVVM 的经验去理解这个模式感觉非常困惑，这个模式的显示界面可以是组件，也可以是qml，但是都有许多很奇怪的特点。 qml还好理解，这里只说组件。组件的view几乎不可控，例如想把表格中某列的数值类型显示成进度条，这里view起不了任何作用，而是通过delegate把渲染好的内容放到界面上……。更有甚者，如果我想让数据有某种作用，我要去修改model，通过model控制显示，why？这不是view应该做的吗？？ 另外这个模式下面还有一个我至今都没理解清楚的问题，就是 ROLE 究竟是干嘛的。role从字面上看应该是起到了角色的作用，Qt的源码里确实也预定义了一些Role，例如read，edit等。但是包括官网的一些网站上的源码，直接用role当作表格的列用。而qt的源码里，判断Role只有等于EditRole才可以编辑……，这种困惑持续了很长时间，一度认为一个表中只有一列可以修改编辑，直到源码中看到了一个flag方法可以覆写。 另外，感觉Model对基础功能的支持比较弱，想要实现什么功能大部分都要去覆写其中的部分方法。写起来很累…… 2.1.2. 坑2： QML QML在灵活性上比组件好太多了。但是依旧有很多问题： QML的版本问题，qml很多组件有多个版本，其中一部分并不是修复加强上一个版本的内容，而是完全抛弃上个版本，新建了一个和上个版本名字相同但内容完全不一样的东西。但是有时需要同时用两个版本，这时IDE就开始出各种奇怪问题了。即使加上别名，也是会报各种错误警告。 另外，我不太理解Qml的设计逻辑，最新版本中的表格控件没有了表头，感觉直接可以叫网格控件了。没有表头就意味着原生的表格没有排序功能，没有调整宽度 ……。如果想要以上功能，直接自己去一项一项的写。另外表头要自己拼外框，然后放在表的上方…… 如果想用好Qml，团队里必须充足的人力进行界面设计，否则还不如不用。 2.1.3. 放弃继续使用Qt 主要有几方面原因： qt的License协议比较复杂，我是没理解太清楚，有可能要开源代码，或者走商业协议 qml的适配性存疑，在Windows下出现控件边框渲染错乱等问题（或者我没调好？）总之难度较大，人力有限，没空调试 我上面提到的各种坑 ","date":"2021-04-10","objectID":"/2021/04/2021-04-10-about-cpp/:2:1","tags":["projection"],"title":"吐槽一下最近开发 c++ 的经历","uri":"/2021/04/2021-04-10-about-cpp/"},{"categories":["技术"],"content":"2.2. Vcpkg 神器，推荐使用。微软维护的开源跨平台（其他平台没试过）管理工具。可以直接编译一些工具。例如GDAL，自己编译即使最小编译也得先编译 sqlite 和 proj，用vcpkg的话基本能实现一句话编译，它自己会下载依赖编译。 Vcpkg 不支持 qt（qmake），只支持Cmake或VC环境 2.2.1. 小缺点 下载时使用的网络国内很不友好，必须搭梯子，否则经常超时然后停止编译。 编译出来的东西实在太过庞大，必须给vcpkg留下几十个G的使用空间 编译速度慢，vcpkg也是下载源码编译，速度可想而知，例如编译GDAL至少需要半天时间 ","date":"2021-04-10","objectID":"/2021/04/2021-04-10-about-cpp/:2:2","tags":["projection"],"title":"吐槽一下最近开发 c++ 的经历","uri":"/2021/04/2021-04-10-about-cpp/"},{"categories":["技术"],"content":"2.3. wxWidgets 现在正在用的界面控件，没有Qt那种可视化的编辑，有点像MFC的编写方式。 这套控件从协议上说，商用没问题，且比Qt轻量级太多。做并不是太复杂的界面问题不大。 ","date":"2021-04-10","objectID":"/2021/04/2021-04-10-about-cpp/:2:3","tags":["projection"],"title":"吐槽一下最近开发 c++ 的经历","uri":"/2021/04/2021-04-10-about-cpp/"},{"categories":["技术"],"content":"3. 一些感想 Windows 写程序，编译程序真坑。Linux下估计早写完了，但是Windows上不一定能用…… 核心功能还是用标准库写吧，省的换界面或者换库时得全部重写…… 继续加油，很头疼 ","date":"2021-04-10","objectID":"/2021/04/2021-04-10-about-cpp/:3:0","tags":["projection"],"title":"吐槽一下最近开发 c++ 的经历","uri":"/2021/04/2021-04-10-about-cpp/"},{"categories":["技术"],"content":"今天大年初二，空气污染，在家复习一下已经忘没的投影知识。 ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:0:0","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"投影分类 @startmindmap projection * 投影分类 ** 按变形性质分类 ***[#lightblue] 等角投影 ***[#lightblue] 等积投影 *** 任意投影 ****[#lightblue] 等距投影 ****[#lightblue] ... ** 按构成方法分类 *** 几何投影 ****[#lightblue] 方位投影 [正轴/横轴/斜轴] ****[#lightblue] 圆柱投影 [正轴/横轴/斜轴] ****[#lightblue] 圆锥投影 [正轴/横轴/斜轴] *** 非几何投影 ****[#lightblue] 伪方位投影 ****[#lightblue] 伪圆柱投影 ****[#lightblue] 伪圆锥投影 ****[#lightblue] 多圆锥投影 ** 切/割投影 ***[#lightblue] 切投影 ***[#lightblue] 割投影 @endmindmap ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:1:0","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"常用投影 ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:2:0","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"世界地图投影 依据不同需求有不同的投影，主要包括： 等差分纬线多圆锥投影 正切差分纬线多圆锥投影 任意伪圆柱投影 正轴等角割圆柱投影 ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:2:1","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"中国地图投影 全国 斜轴等面积方位投影 斜轴等角方位投影 彭纳投影 伪方位投影 正轴等面积割圆锥投影 正轴等角割圆锥投影 分省（区） 正轴等角割圆锥投影 正轴等面积割圆锥投影 正轴等角圆柱投影 高斯-克吕格投影 大比例尺 高斯-克吕格投影 ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:2:2","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"墨卡托投影 正轴等角切圆柱投影 ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:2:3","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"高斯-克吕格投影 又名 横轴墨卡托投影 属于 横轴等角切椭圆柱投影 为减少形变分为3度带和6度带 ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:2:4","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"Web 墨卡托投影 墨卡托的变体，计算速度快，但是相对墨卡托有形变，不太要求精度的显示还可以，其他不建议使用 ","date":"2021-02-13","objectID":"/2021/02/2021-02-13-projection/:2:5","tags":["projection"],"title":"投影分类","uri":"/2021/02/2021-02-13-projection/"},{"categories":["技术"],"content":"1. 背景 最近在维护一个非 Restful 接口风格的项目。由于习惯了设计 Restful 风格的接口，每当在这个项目中添加接口时就特别纠结，总有种无从下手的感觉。或许我有强迫症？？ 🙃 趁这个感觉很别扭的机会总结一下设计思路 为了方便描述，先假设一个场景，现在有班级和学生两个表，要对这两个表设计接口 班级表： id name 1 一班 2 二班 学生表： id class_id name age 1 1 甲 10 2 1 乙 11 3 2 丙 10 4 2 丁 11 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:1:0","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"2. Restful 风格接口核心设计思想 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:2:0","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"2.1. 一切以 资源 为核心 Restful 风格的设计中，全部的操作都是围绕 ##资源## 进行的，这是最中心的思想。+ 例如上面的例子中，资源有2个，班级和学生。那么接下来的设计就需要从班级和学生入手 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:2:1","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"2.2. url 中 不要出现 任何动词 设计的url中 不要出现 类似 add、list、delete、start、stop 等任何动词，如果以前没有设计过 Restful 风格接口的话这点会很不适应。但是我感觉这是 Restful 风格显得特别工整的关键。尤其多人的项目，质量又把控不严的情况下，各种五花八门的动词都出现了。例如在同一工程下同时用 delXXX 和 deleteXXX 表示删除。 同时这种设计使接口更简短直接，能很明白的知道操作的是什么资源。 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:2:2","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"3. Restful 中的五大方法 GET :: 无论是不是 Restful 风格，这个应该使用最多的方法，获取数据，可能为单个资源或数组 POST :: 也是特别常用的一个，Restful 风格中它代表的是添加，也就是数据库中的 insert PUT :: 更新，这个在非Restful 风格中可能用的不多，意思是更新，数据库中的 update DELETE :: 字面意思，删除 PATCH* :: 这个用的稍微少一些，部分更新，我自己用的比较少，大部分接口实现 put 就够了 由于 Restful 风格中不允许使用动词，这几个方法就代替了动词的作用，需要合理使用 NOTE: 上面提到的 start、stop 等方法在 Restful 风格中不能直接体现，一般用 PUT 方法修改资源的状态代替，例如 put {“status”: “start”} ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:3:0","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4. Restful 设计细节 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:0","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4.1. 资源名称的设计 资源肯定都是名词，这都不用细说，另外还有一些官方推荐或我自己的一些建议： 资源（包括url）全部小写 资源都为复数，例如上面的班级，要设计成 classes，学生为 students 如果资源是多个词，可用减号连接。例如 书包 可以写成 school-bags ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:1","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4.2. 资源操作设计 其实就是如何使用上面的几种方法，这些都有既定的模板 4.2.1. 获取资源列表 获取全部资源或者获取某种条件下的部分资源，条件可以通过参数传入 例如获取全部班级信息： GET {base_url}/classes?name=一班 4.2.2. 获取单个资源 通过 ID 获取资源，这里一般把 ID 设计到url路径中，例如： GET {base_url}/classes/{class_id} 4.2.3. 提交资源 提交（添加）资源，使用 POST 方法，参数一般为资源的json，例如: POST {base_url}/classes content可以为class的json 4.2.4. 删除资源 同上，以班级为例 DELETE {base_url}/classes/{class_id} 4.2.5. 更新资源 PUT 或 PATCH {base_url}/classes/{class_id} 参数与POST类似 4.2.6. 资源操作模板 稍微总结一下，大部分的接口都可以套用模板 资源操作模板： 操作 方法 url设计 添加 POST {base_url}/resources 获取全部 GET {base_url}/resources 获取单个 GET {base_url}/resources/{resource_id} 删除 DELETE {base_url}/resources/{resource_id} 更新 PUT 或 PATCH {base_url}/resources/{resource_id} ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:2","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4.3. 资源分层设计 在上面的例子中，班级和学生是一对多的关系，可以认为有层级关系，如果想查询某个班里学生的情况，可以在班级后接学生的资源，例如： GET {base_url}/classes/{class_id}/students 同时 students 资源也适用于上面的资源操作模板 TIP: 这里为了说明分层的设计，认为学生只依赖与班级存在 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:3","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4.4. 验证设计 有时接口中会出现验证的需求，例如传 token等 这里我一般是把验证信息放在请求的 header 里面，在 header 中添加 Authorization: \u003ctype\u003e \u003ccredentials\u003e 例如 Authorization: Basic 1234567... ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:4","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4.5. 状态设计 在 Restful 风格中，http的状态编码特别重要，这些状态码存在 header 中，可在数据处理前先验证状态， 这里我一般使用HTTP的默认状态码，我感觉一般情况下足够用了，详见 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status[status code] ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:5","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4.6. 返回设计 4.6.1. GET 单个资源返回 我的建议是不要在外面套任何东西，请求什么资源就返回什么资源。 如果请求错误的话有 http status code 的错误代码，内容中可以加上错误信息。正确的话返回一个表示正确的代码有啥用？？在外面套一层没啥用的东西在我看来就是浪费解析资源。 4.6.2. GET 列表 这里我的习惯是列表全部分页处理，分页参数可以依据需求设计，放在url中，例如 resources?pageSize=10;pageNum=10。返回中包括分页的信息及数组，这里数组外面会包一层分页信息 4.6.3. POST/PUT/PATCH 返回 我的建议是返回插入/修改后的资源，结构同单个资源返回 4.6.4. DELETE 返回 这里可以什么都不返回，200就足够了…或者返回删除的ID等 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:6","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"4.7. 返回错误设计 接口中肯定要处理错误请求等，这时一定要返回的是上面提到的 http status code，错误内容可选返回或不返回，看需求处理 4.7.1. 另外一些错误情况 get单个信息如果id没有找到一般返回 404，表示没有资源 如果列表查询中，没有返回，可以返回 204，或灵活处理 删除中遇到找不到要删除ID的情况，这时如果要删除的东西比较重要，可以返回 4xx ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:4:7","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"5. 总结 Restful 风格并不是一种强制的标准或规范，如何实现可以根据情况自行调整。 我感觉使用 Restful 风格能带来几点好处： url 更加精简漂亮 设计者和使用者一眼就能明白接口的作用 类似模板的设计流程可以加快设计速度 很多插件或工具对符合 Restful 风格的接口很友好，可以少些很多处理解析逻辑，很大程度上减少了代码量 ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:5:0","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"6. 附录 restfulapi.net 推荐返回值 方法 集合(eg. /users) 单个项目 (eg. /users/123) POST 201 禁止使用 GET 200 200(OK)/404(Not Found) PUT 405(不支持) 200(OK)/404(Not Found) PATCH 405(不支持) 200(OK)/404(Not Found) 更新 405(不支持) 200(OK)/404(Not Found) ","date":"2021-01-13","objectID":"/2021/01/2021-01-13-restful-design/:6:0","tags":["rest"],"title":"Restful 风格接口设计总结","uri":"/2021/01/2021-01-13-restful-design/"},{"categories":["技术"],"content":"背景 这应该是今年最后一个帖子了，由于准备在java中使用gdal，而现在各种预编译版本中一般没有java的支持，需要自己编译。上班时用的 Linxu系统，很好编译，基本配置好环境，一个make就可以了，但是回家为了玩儿会儿游戏用的 Windows 系统，编译就比较曲折了，这里记录一下。 如果不需要java等支持，可以直接使用Conda的方式安装 ","date":"2020-12-31","objectID":"/2020/12/2020-12-31-gdal-windows-build/:1:0","tags":["gdal","windows"],"title":"windows下编译GDAL记录","uri":"/2020/12/2020-12-31-gdal-windows-build/"},{"categories":["技术"],"content":"1. 使用版本 Visual Studio 2017 sqlite3 3.34.0 proj 6.3.2 gdal 3.1.4 ","date":"2020-12-31","objectID":"/2020/12/2020-12-31-gdal-windows-build/:2:0","tags":["gdal","windows"],"title":"windows下编译GDAL记录","uri":"/2020/12/2020-12-31-gdal-windows-build/"},{"categories":["技术"],"content":"2. 编译流程 sqlite → proj → gdal ","date":"2020-12-31","objectID":"/2020/12/2020-12-31-gdal-windows-build/:3:0","tags":["gdal","windows"],"title":"windows下编译GDAL记录","uri":"/2020/12/2020-12-31-gdal-windows-build/"},{"categories":["技术"],"content":"3. 安装 Visual Studio 2017 这里安装的 Visual Studio 2017 的 Community 版本，这个版本自己用足够了，只安装的 c++ 支持，网络安装，还好网比较快，大概半个小时安装完成，不再细说 ","date":"2020-12-31","objectID":"/2020/12/2020-12-31-gdal-windows-build/:4:0","tags":["gdal","windows"],"title":"windows下编译GDAL记录","uri":"/2020/12/2020-12-31-gdal-windows-build/"},{"categories":["技术"],"content":"4. 编译 sqlite3 安装这里有点坑，看其他帖子，很多写的是直接下载dll那个，但是我没测试成功过，且提供的编译好的exe只有32位，而proj编译需要exe文件 折腾了小半天后决定自己安装，直接下载 源码 先要安装 Tcl ActiveTcl下载地址 安装完成后编译 编译时参考的 这里 其实就是在vs控制台环境里面执行 nmake /f Makefile.msc TOP=..\\sqlite， exe 等文件就会生成到本页面。这时proj和gdal基本就可以用这个文件夹了。 ","date":"2020-12-31","objectID":"/2020/12/2020-12-31-gdal-windows-build/:5:0","tags":["gdal","windows"],"title":"windows下编译GDAL记录","uri":"/2020/12/2020-12-31-gdal-windows-build/"},{"categories":["技术"],"content":"5. 编译 proj 这里使用的是 Cmake 编译，可以使用 cmake 的ui进行简单操作 config报错后修改以下几项 EXE_SQLITE3 : D:/Codes/sqlite/sqlite3.exe SQLITE3_INCLUDE_DIR : D:\\Codes\\sqlite SQLITE3_LIBRARY : D:/Codes/sqlite/sqlite3.lib 可选修改项： CMAKE_INSTALL_PREFIX : D:\\Work\\proj 修改后在页面执行 Generate → Open Project 打开vs工程 vs 工程中可直接在 生成 → 批生成 中选择 ALL_BUILD 和 INSTALL 的 Release|x64 项目，执行后会直接把工程输出到 CMAKE_INSTALL_PREFIX 设置的路径中。这里基本完成 proj 的编译 ","date":"2020-12-31","objectID":"/2020/12/2020-12-31-gdal-windows-build/:6:0","tags":["gdal","windows"],"title":"windows下编译GDAL记录","uri":"/2020/12/2020-12-31-gdal-windows-build/"},{"categories":["技术"],"content":"6. 编译 GDAL 这里暂时编译最简版本，以后需要再扩展编译 直接 下载gdal源码，gdal直接支持nmake编译，会比sqlite和proj简单点，不过编译过程需要几个项目的参与，需要另外下载，我目前需要的有： ANT SWIG JAVA 下载后可修改gdal源码中的 nmake.opt 文件，或直接在参数中指定。然后执行下面语句： nmake -f makefile.vc MSVC_VER=1910 WIN64=1 GDAL_HOME=D:\\Work\\gdal_3.1.4 PROJ_INCLUDE=-ID:\\Work\\proj_6.3.2\\include PROJ_LIBRARY=D:\\Work\\proj_6.3.2\\lib\\proj.lib SQLITE_INC=-ID:\\Work\\sqlite SQLITE_LIB=D:\\Work\\sqlite\\sqlite3.lib BINDINGS=java install 最后加上 install 才会把编译好的输出到 GRADLE_HOME，这里他的示例都没写 编译完成后就可以在 GRADLE_HOME 中看到编译好的可执行文件了 另：编译后的好像没找到 jni 相关的dll，明年再看了。 祝大家新年快乐！ ","date":"2020-12-31","objectID":"/2020/12/2020-12-31-gdal-windows-build/:7:0","tags":["gdal","windows"],"title":"windows下编译GDAL记录","uri":"/2020/12/2020-12-31-gdal-windows-build/"},{"categories":["技术"],"content":"1. 配置 kudu ","date":"2020-12-04","objectID":"/2020/12/2020-12-04-kodo-dev/:1:0","tags":["kudu","impala"],"title":"kudu + impala 测试环境搭建及测试","uri":"/2020/12/2020-12-04-kodo-dev/"},{"categories":["技术"],"content":"1.1. 配置执行环境 直接使用官网 quickstart 的部署方法，使用docker安装。 docker 安装方法可见另一个帖子 使用 docker-machine 安装docker。 我使用的是win10 自带的 hyper-v 虚拟机 docker 创建方法 使用的创建语句如下： docker-machine create -d hyperv --hyperv-cpu-count 4 --hyperv-memory 8192 --hyperv-virtual-switch \"P Default Switch\" docker-default 这里我设置了，4核8G，其他参数可执行 docker-machine create -d hyperv --help 查看。如果使用的是virtualbox，替换 hyperv 即可 执行 create 一定要用git带的那个 bash，可以搜索bash，再右键用管理员运行。如果用windows自带的 powershell，会一直卡在 Waiting for SSH to be available…​ 处 ","date":"2020-12-04","objectID":"/2020/12/2020-12-04-kodo-dev/:1:1","tags":["kudu","impala"],"title":"kudu + impala 测试环境搭建及测试","uri":"/2020/12/2020-12-04-kodo-dev/"},{"categories":["技术"],"content":"1.2. 测试执行 需要设置 KUDU_QUICKSTART_IP 参数，官网上写的是 export KUDU_QUICKSTART_IP=$(ifconfig | grep \"inet \" | grep -Fv 127.0.0.1 | awk '{print $2}' | tail -1) ,由于使用的客户端是 Windows 系统，无法执行官网提供的命令，这里可以直接把它配置在系统的环境变量中，key为 KUDU_QUICKSTART_IP，值为docker虚拟机IP eg. 192.168.1.123 执行 docker-compose -f quickstart.yml up -d。 原以为这里只使用 quickstart.yml 就可以，结果发现文件中引用了当前目录，因此，有必要把工程clone下来再执行 docker-compose 第一次执行时可以不用 -d 参数，方便看日志。 ","date":"2020-12-04","objectID":"/2020/12/2020-12-04-kodo-dev/:1:2","tags":["kudu","impala"],"title":"kudu + impala 测试环境搭建及测试","uri":"/2020/12/2020-12-04-kodo-dev/"},{"categories":["技术"],"content":"2. 配置 impala docker run -d --name kudu-impala --network=\"docker_default\" \\ -p 21000:21000 -p 21050:21050 -p 25000:25000 -p 25010:25010 -p 25020:25020 \\ --memory=4096m apache/kudu:impala-latest impala 访问docker服务的 25000 端口即可看到界面 ","date":"2020-12-04","objectID":"/2020/12/2020-12-04-kodo-dev/:2:0","tags":["kudu","impala"],"title":"kudu + impala 测试环境搭建及测试","uri":"/2020/12/2020-12-04-kodo-dev/"},{"categories":["技术"],"content":"3. 连接测试 在cloudera上下载impala的jdbc驱动，下载免费，但是需要注册。 在 dbeaver 上配置jdbc，并设置driver类 Figure 1. 配置jdbc Figure 2. 成功连接 ","date":"2020-12-04","objectID":"/2020/12/2020-12-04-kodo-dev/:3:0","tags":["kudu","impala"],"title":"kudu + impala 测试环境搭建及测试","uri":"/2020/12/2020-12-04-kodo-dev/"},{"categories":["技术"],"content":"4. 测试添加数据 这里用的是网上下载的测试数据，共10w条 先创建表 Figure 3. 创建表 Figure 4. 导入数据 模拟集群就是不一样，这速度，可以先睡一觉…… 😂 Figure 5. 处理中 Figure 6. 完成数据传输（非真实数据） ","date":"2020-12-04","objectID":"/2020/12/2020-12-04-kodo-dev/:4:0","tags":["kudu","impala"],"title":"kudu + impala 测试环境搭建及测试","uri":"/2020/12/2020-12-04-kodo-dev/"},{"categories":["技术"],"content":"5. 总结 kudu+impala的docker测试环境很简单，官网说明也比较详细，不过需要修改一些docker的默认设置， 加上kudu的说明都是基于Linux或Mac系统，在Windows上测试需要有些处理docker的经验。 测试体验： 出乎意料的顺利，没碰到什么大坑，kudu做的这个体验版还是不错的 上传速度极慢，可能原因是这是用docker模拟的集群，资源有限，有时间再在正式集群环境上测试 数据可以顺利修改 ","date":"2020-12-04","objectID":"/2020/12/2020-12-04-kodo-dev/:5:0","tags":["kudu","impala"],"title":"kudu + impala 测试环境搭建及测试","uri":"/2020/12/2020-12-04-kodo-dev/"},{"categories":["技术"],"content":"1. 升级背景 模块化: 指的是从 java9 开始的 java-module Jigsaw ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:1:0","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"1.1. 升级相关情况及目的 新增功能更方便的模块化 模块系统中可以使用 jlink 压缩java环境，减小最终体积 Java11 为长期支持版本，理论会比其他版本稳定。 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:1:1","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"1.2. 升级前环境 java8环境 gradle管理依赖 Springboot环境 工程分布在多个jar包中 有混淆逻辑 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:1:2","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"2. 注意事项 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:2:0","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"2.1. 模块化 过程很简单，也很复杂，在java根目录加上 module-info.java，再在里面加上依赖及发布内容。 需要注意，网上一些（一大部分）添加 module-path 的方式是遍历task，只要有编译的就加上 module-path。这种方式会让单元测试报找不到 module-path 的错误，解决方式是只在 compileJava 中添加 module-path。 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:2:1","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"2.2. 模块化中的依赖 其实这也是升级前的最初想法，以前依赖过重，不同版本重复jar包过多，甚至还有各种魔改jar包，有时会出现奇怪的玄学问题。 模块系统对依赖特别严格，升级前必须把工程的依赖关系最简化，这关系到原有程序能不能升级为模块系统。 由于升级前的工程需要验证kerberos，再加上hive等的客户端验证，需要依赖hadoop。而hadoop的依赖只有你想不到的……，查看依赖，只算各式各样的jackson就不下五六种。 因此解决依赖分为了几步： 重新设计kerberos的客户端，去掉对hdfs包里面的用户验证的依赖 使用webhdfs代替hdfs，直接使用rest服务访问而不是使用jar包，去掉了对 hdfs 的依赖 连接hive的driver改为反射读取，去掉直接的工程内部依赖 由于以前多个子工程使用了很多相同的包路径，这在非模块系统中很方便，但是模块系统中反而是个麻烦 模块系统中，如果多个依赖 module（jar包）中有相同的 package，且相同package下都有需要对外发布的class，会报冲突。如果想解决，只能自己再封装jar包，比较麻烦。 eg. a.jar 中包含 package c.d.e ，且此包中有 f.class b.jar 中也包含 package c.d.e ，且此包中有 g.class 如果一个工程同时依赖 a.jar 和 b.jar，则会报冲突。比较常见的解决方法就是把 a.jar 和 b.jar 合并为一个jar包。 经过一系列修改后完成了依赖的最简化，实现了引用的不冲突。 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:2:2","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"2.3. 混淆 这次的升级顺便修改了混淆的思路，以前是各个子工程不混淆，最后一个门户工程再统一打包混淆；本次升级直接混淆各个子工程，门户工程反而因为没啥具体内容，可以不再混淆。 这样的改变其实和模块化有一定关联，模块化中需要在 module-info.java 中指明外部能够访问的内容，且各个模块不能再相同的package下写可执行的内容。如果放到最后再混淆会有以下几个问题： 每次新添加模块都要考虑修改混淆脚本（路径不同） 不能动态的添加模块（每次新加模块都要重新混淆工程） 每个模块里面对外发布的内容可以都写成接口，混淆时规定接口不混淆。不准备对外的类可以实现接口，然后添加该类的 Builder 类，暴露出不混淆的接口和 Builder 即可。 2.3.1. gradle 发布到 nexus 技巧（maven-publish 插件） 混淆前的jar包打包及发布逻辑不动 混淆后的内容生成jar包时在名称中添加自定义的 classifier，用 artifact 方式和原始jar包一起发布到nexus服务 使用的工程用 compile 'group:name:version:classifier'，引入依赖，就是在常用的依赖后面加上冒号+自定义的classifier名称 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:2:3","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"2.4. jlink 这里是比较难的一块，大概用了两天时间才完成，使用的是 org.beryx.jlink 插件，它能够把工程中非module的包打包成一个（自动执行上面提到的合并jar包过程），然后根据依赖生成精简后的jdk。这里难点有几个： 像是springboot这种结构比较分散的不好确定依赖，我的流程基本是 测试 → 看错误信息 → jlink中添加依赖，这样的流程重复了几十遍。 打包速度慢，一次大概得几分钟 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:2:4","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"2.5. docker打包 这里原以为很简单，实际又跳坑里了。由于jlink打包了jdk，最开始使用的是 alpine 作为基础，但是一直报找不到 java 的错误，后来查资料才知道是alpine中缺少环境。改用 alkoclick/alpine-jdk11-nojdk:latest，成功完成打包。 ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:2:5","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"3. 成果 经过一系列的调整，最直接可见的成果是最后打包docker的体积减小了约60% ","date":"2020-11-22","objectID":"/2020/11/2020-11-22-java-update-to-11/:3:0","tags":["java","docker","jlink","proguard"],"title":"java8升级到java11的模块系统","uri":"/2020/11/2020-11-22-java-update-to-11/"},{"categories":["技术"],"content":"我一般用树莓派当服务器用，因此一般不安装界面，直接安装最简版，但是正常的安装过程需要把树莓派做好后再连接一个显示器进行配置。下面整理了不用再连接显示器进行配置使用的方法。 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:0:0","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["技术"],"content":"1. 安装树莓派 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:1:0","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["技术"],"content":"1.1. 镜像拷贝工具下载安装 我使用的是 balenaEtcher 这是一个开源的镜像安装工具 Figure 1. balenaEtcher 使用很简单，按上面的步骤即可 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:1:1","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["技术"],"content":"1.2. 下载最新的树莓派安装镜像 国内不建议用官网给的那个工具安装，实在慢的没谱。建议直接下载 镜像 Figure 2. 树莓派镜像 因为我不用界面，下载的那个最小的，这里可以根据需要选合适的下载。 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:1:2","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["技术"],"content":"2. 镜像制作 把sd卡通过读卡器接入电脑 在 etcher 工具里面点击 Flash from file，选择刚下载好的树莓派官网镜像（zip格式，不用解压） 在 etcher 工具里选择刚插入的sd卡 点击 flash 会自动刷入，直至结束，结束后会自动退出sd卡 如果使用的是windows系统，写好的sd卡重新插入会有几个盘不能读取，会跳出是否格式化，这里点击 取消! Figure 3. 这里取消 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:2:0","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["技术"],"content":"3. 无显示器配置 重新插入sd卡，注意不要格式化任何盘。 此时会有一个名称为 boot 的盘是可读写状态 Figure 4. 可配置盘 其实连接显示器主要是想设置2点 SSH连接 网络设置 只要设置好上面两点，即可开启远程连接 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:3:0","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["技术"],"content":"3.1. 开启SSH连接 只需在 boot 盘中加入一个空的名称为 SSH 的文件即可 Figure 5. 开启SSH 这里注意不要有扩展名什么的，如果 windows 设置了已知扩展名隐藏，建议打开 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:3:1","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["技术"],"content":"3.2. 网络IP设置 我直接连接的网线，因此要设置有线网卡的固定IP，这时编辑 boot 盘中的 cmdline.txt 文件 Figure 6. 添加静态IP 这里要注意空格的情况，两个参数之间有空格，参数内部，等号两侧无空格 无线设置需要添加 wpa_supplicant.conf 文件，网上有很多教程，这里就不写了 设置完成这些，配置基本就完成了。 下面可以把卡插入树莓派，然后开机连网线了。等十几秒后就可以测试用xshell等客户端进行连接了。 树莓派默认用户名：pi 密码： raspberry Figure 7. xshell进入树莓派 ","date":"2020-11-19","objectID":"/2020/11/2020-11-19-raspberry-pi-install/:3:2","tags":["树莓派"],"title":"树莓派-无显示器安装系统","uri":"/2020/11/2020-11-19-raspberry-pi-install/"},{"categories":["旅行"],"content":"由于疫情，今年没有去太远的地方，为了打个时间差，10月5日出发，10日返回 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:0:0","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"1. 相关行程 时间： 2020-10-05 ~ 2020-10-9 共5天 交通： 自驾 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:1:0","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"2. 旅游经历 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:2:0","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"2.1. 10月5日 太原-晋祠 从家出发，一路到山西省太原市，早上五六点出发，中午到达太原市晋源区，先入住酒店，在晋阳湖附近。 由于不知道景区停车场情况，下午直接打车去了 晋祠。 路上听司机师傅说住的这附近景点很多，要去的晋祠很多古建筑，等等。 晋祠分为外面的晋祠公园和靠里面的晋祠博物馆，晋祠公园免费，晋祠博物馆工作日免费，节假日收费。国庆期间只能买票进去了。 Figure 1. 晋祠圣境 Figure 2. 圣母殿 Figure 3. 难老泉 Figure 4. 难老泉 Figure 5. 古树 晋祠给人印象最深的是古朴的建筑，面积不算大，但是内容相当丰富。 转完后时间也比较晚了，回酒店休息。 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:2:1","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"2.2. 10月6日 太原 以前没来过太原，今天准备再待一天，但是计划有些失误。 上去去了酒店附近的 晋阳湖，面积特别大，听当地人说这是以前的鱼塘连起来的，不知道是去的太早还是怎么回事儿，人很少。景区内整理的很干净，但是相应的设施好像还在建设中，有些空荡荡的感觉。湖南面有个观景台，能看湖面的景色和不太远的鸟岛，可能是季节原因，只能看到几只野鸭捕鱼。 由于晋阳湖面积太大，只在湖南边转了一会儿。准备去附近的古城，结果古城暂停营业；又说去新开的植物园，结果发现植物园的票在国庆前就已经被预定光了。然后直接去的森林公园。森林公园的面积不小，地势有些起伏。很多人在里面休闲、锻炼。公园里面有个高尔夫球场，占地面积也不小，被公园的路包围着。转了一圈后准备去附近的汾河观景平台，结果发现也正在修。 下午去的 柳巷街，是个比较热闹的商业街，对买东西不太感兴趣，也就没太逛。不过在逛柳巷街时发现了 文瀛公园 公园很小，但是特别热闹，也很有公园的氛围。这个公园很有历史了，曾用过人民公园的名称，可见它的重要。公园很漂亮，比今天去的其他地方好上太多。正好赶上公园的菊花展，看了一些各式各样的菊花。 Figure 6. 菊花展 Figure 7. 菊花展 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:2:2","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"2.3. 10月7日 临汾-壶口瀑布 这是这次旅行最不虚此行的一天，我们去了 壶口瀑布。早上一大早就出发，中午才到了山西壶口瀑布。 壶口瀑布的两岸分别处在山西景区和陕西景区。壶口瀑布是个不垂直于河岸的斜面，山西景区看到的面更大，更壮观一些。 正好最近涨水，水量特别大，来的很是时候。有两座去和中心看瀑布的桥，据管理人员说，昨天的河水已经淹没了其中一座。 壶口瀑布顶端 Your browser does not support the video tag. 壶口瀑布 Your browser does not support the video tag. Figure 8. 壶口瀑布 Figure 9. 壶口瀑布 Figure 10. 壶口瀑布 由于水太大，景区关闭了位置比较靠下的平台，看不到黄河之水天上来的情景了。景区不算大，一小块地方，但是景色很震撼，值得一去。 壶口瀑布离其他景点太远，这天只安排了一个地方。晚上到临汾市区休息。住的临汾市区的老城区，真得吐槽一下那里的交通，太乱了。 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:2:3","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"2.4. 10月8日 晋中-平遥古城 这天去的平遥古城，一大早出发，10点多到的平遥，先在古城门口附近入住了酒店，把车停在了那里。步行进了景区 Figure 11. 入口 Figure 12. 城门 Figure 13. 砖雕 Figure 14. 院子 由于假期最后一天，人相对来说少了一些，面积不小。各处景点的转，去了城墙，文庙，日升昌等景点。买了些东西，地方太大，转到晚上天黑才到酒店休息。 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:2:4","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"2.5. 10月9日 晋中-乔家大院 常家大院 这是出行计划的最后一天，去了乔家大院和常家庄园。由于已经是工作日了，都是免门票入园。 这里离着平遥古城比较近了，早上就到了。 Figure 15. 乔家大院入口 广场很大，得走了一会儿。入口直接点昨天预定的票，免费进去了。 大院里面院子太多了。一间挨一间的转，这里的院子风格比较统一。来这里看建筑，看历史。 Figure 16. 垂花柱 里面的 垂花柱 格式各样，很漂亮。 Figure 17. 保元堂 这里转了一上午，学到了很多这里的风俗习惯，了解了很多晋商的历史。不错的经历。 下午去了常家庄园，跟着导航各种大路小路的走，感觉地点有点偏…… 整个景区都特别古朴，看着就像是几十年没修过似的，很有古镇的感觉。常家庄园一进门口就是常家祠堂，古朴的院子和建筑让人有种穿越的感觉。 不知道是不是假期结束的原因，人特别少，甚至到了四五点后，很少能见到游客，是个拍照的好地方。 Figure 18. 雕栏 虽然是雕梁画栋，但是漆面大部分已经剥落。 Figure 19. 夕阳下的大门 Figure 20. 院子 Figure 21. 街道 傍晚到晋中市区的酒店休息，结束一天的行程。 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:2:5","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"2.6. 10月10日 收拾东西回家，结束这次旅程。 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:2:6","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["旅行"],"content":"3. 结语 这次旅行总体上来说还算很不错的，学习参观了山西的各种文化，包括建筑、自然风光、晋商发展等。这次虽然没遵循以前每到一个地方先逛当地博物馆的习惯，但是还是从游览中体会到了很多书本上读不到的。 这次最值得去的是参观了壶口瀑布，并且幸运的赶上了合适的时间和极好的天气，领略到了黄河的气势磅礴。其实来壶口瀑布之前还是比较犹豫的，毕竟离其他计划的地方太远了，要花一天的时间看一个景点。不过结果很超乎想象，这一天时间很值。 ","date":"2020-11-08","objectID":"/2020/11/2020-11-08-tourism-shanxi/:3:0","tags":["生活"],"title":"2020年10月山西自驾游","uri":"/2020/11/2020-11-08-tourism-shanxi/"},{"categories":["技术"],"content":"树莓派买来闲置有段时间了，搭一些简单的服务有点浪费，这次准备用起来 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:0:0","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"配置树莓派 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:1:0","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"安装服务 这里选择了比较简单的 nginx-light 有其他需求也可以部署apache，tomcat 等 安装nginx sudo apt install nginx-light 设置自启及启动 sudo systemctl enable nginx sudo systemctl restart nginx ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:1:1","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"建立测试网页 新建测试页面 sudo mkdir -p /var/www/html/demo sudo sh -c 'cat \u003e /var/www/html/demo/index.html \u003c\u003c EOF \u003chtml\u003e \u003cbody\u003e \u003cheader\u003ehello my site \u003c/header\u003e \u003c/body\u003e \u003c/html\u003e EOF' def flatMap[B, That](f: A =\u003e GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = { def builder = bf(repr) // extracted to keep method size under 35 bytes, so that it can be JIT-inlined val b = builder for (x \u003c- this) b ++= f(x).seq b.result } @Test public void testStream(){ List\u003cList\u003cString\u003e\u003e demo = Arrays.asList( Arrays.asList(\"a\",\"b\"), Arrays.asList(\"c\",\"d\")); List\u003cString\u003e result = demo.stream() .flatMap(Collection::stream) .collect(Collectors.toList()); result.forEach(System.out::print); } 然后可以访问一下 http://{树莓派IP地址}:80/demo ,如果正常出现 hello my site 证明部署成功。 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:1:2","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"申请免费域名 从freenom 申请免费域名，这个网站最好翻墙进去，否则特别容易卡死。 首先注册账号，或者直接用google账号登陆，我比较懒，直接用google账号了。 说明 这里默认是3个月，最多可选择12个月 说明 这里有个坑，后来发现是代理问题，不要用浏览器代理，可以设置成系统代理，然后在浏览器级别设置为系统代理，再购买即可。 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:2:0","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"内网穿透 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:3:0","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"注册账户及开通隧道 内网穿透需要有公网服务器，感觉暂时买服务器没啥用，就找到了免费的 ngrok 服务 sunny-ngrok，它提供了 ngrok 和 frp 服务器，但是免费的只有 ngrok 官网教程 建议看一下，里面有安装方法，主要看这两个： ngrok安装 和 开机自启动 。 自定义域名 如果使用自定义域名，这里也建议看一下 点击开通隧道，免费的只有这个，自己玩凑合点也可以了 这里勾选 自定义域名，然后在自定义域名那里写下刚才申请的域名 说明 这里如果使用 freenom 自己的 DNS，最好在域名前面加 www. 如果托管的其他的DNS再看情况 注意这句，等会儿要用到 请把域名CNAME解析到free.idcfengye.com ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:3:1","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"客户端部署 如何在客户端部署直接看官网文档就可以了，很简单。如果修改隧道后记得重启客户端 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:3:2","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"设置DNS 登录 freenom 说明 注意NAME关系到使用的网址，这里好像还不支持 @ ，就用 www 了，这也是上面填自定义域名的时候加上了 www 的原因 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:4:0","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"测试连接 上面的部署完成后可能不能马上测试成功，DNS需要一定时间刷新。可以过一段时间刷一下试试，测试网址 http://www.{自定义域名}.tk/demo ，如果出现 hello my site 则证明发布成功 最后可以自己在树莓派建立自己的站点了 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:5:0","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"进一步升级 还可以把DNS托管给 DNSpod 等，不清楚国内管理怎么样，暂时还是用freenom的DNS了 另外准备试试 cloudflare 看能不能免费申请 https 的证书 ","date":"2020-07-08","objectID":"/2020/07/2020-07-08-raspberry-pi-website/:6:0","tags":["树莓派","网络","内网穿透"],"title":"树莓派部署免费公网站点","uri":"/2020/07/2020-07-08-raspberry-pi-website/"},{"categories":["技术"],"content":"flatMap 是个很神奇的东西，一般是学习 scala 的第一个坎儿，其实很简单，下面分别从 Scala，Spark（Dataset），Java8（lambda）说明flatMap的使用 ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:0:0","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"1. 在 Scala 中的使用 flatMap 在scala的参数需要的返回是 GenTraversableOnce，下面是实现： def flatMap[B, That](f: A =\u003e GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That = { def builder = bf(repr) // extracted to keep method size under 35 bytes, so that it can be JIT-inlined val b = builder for (x \u003c- this) b ++= f(x).seq b.result } GenTraversableOnce（遍历器？不知道怎么翻译）包含最基础的遍历方法，Iterable，Seq，List等都是继承自这里，下面是比较有意思的一点： ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:1:0","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"1.1. 过滤 None 值 Scala里的Optional，很重要的一句，把Option隐式转换为 Iterable object Option { // ...... /** An implicit conversion that converts an option to an iterable value */ implicit def option2Iterable[A](xo: Option[A]): Iterable[A] = xo.toList // ...... } 再看 toList 的实现： /** Returns a singleton list containing the $option's value * if it is nonempty, or the empty list if the $option is empty. */ def toList: List[A] = if (isEmpty) List() else new ::(this.get, Nil) Optional 可直接转换为 Iterable，如果为空，返回空数组，如果不是则返回单个值，很神奇的操作…… 于是有了下面的操作 class FlatMapTest extends AnyFlatSpec with Matchers { it should \"过滤空值\" in { val result = Seq(1, 2, 3, 4, 5, 6, 7, 8).flatMap { v =\u003e if(v % 2 == 0){ Some(v) }else { None } } result should be(Seq(2,4,6,8)) } } ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:1:1","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"1.2. 正常 flatMap 操作 很正常的操作，把内部数组向上提 示例： class FlatMapTest extends AnyFlatSpec with Matchers { it should \"真.flatMap\" in { val result = Seq(\"a.b\",\"c.d\").flatMap(_.split(\"\\\\.\")) result should be(Seq(\"a\", \"b\", \"c\", \"d\")) } } ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:1:2","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"2. 在spark（Dataset）中使用 基于 Optional 的神奇特性，spark 中 Dataset 的 flatmap也有类似功能 下面是spark的 flatMap 需要的返回值是 TraversableOnce 这是 GenTraversableOnce 的子类，使用上面的经验完全没问题。 /** * :: Experimental :: * (Scala-specific) * Returns a new Dataset by first applying a function to all elements of this Dataset, * and then flattening the results. * * @group typedrel * @since 1.6.0 */ @Experimental @InterfaceStability.Evolving def flatMap[U : Encoder](func: T =\u003e TraversableOnce[U]): Dataset[U] = mapPartitions(_.flatMap(func)) 直接上示例： import org.apache.spark.sql.SparkSession import org.junit.runner.RunWith import org.scalatest.flatspec.AnyFlatSpec import org.scalatest.matchers.should.Matchers import org.scalatestplus.junit.JUnitRunner case class Demo(name: String, inUse: Boolean) @RunWith(classOf[JUnitRunner]) class FlatMapTest extends AnyFlatSpec with Matchers { private val spark = SparkSession.builder().master(\"local\").getOrCreate() import spark.implicits._ private val ds = spark.createDataset(Seq( Demo(\"a.b\", inUse = true), Demo(\"c.d\", inUse = false))) it should \"过滤用\" in { val result = ds.flatMap{d =\u003e if(d.inUse){ Some(d) }else{ None } } result.collect().head should be (Demo(\"a.b\", inUse = true)) } it should \"真.flatMap\" in { ds.flatMap( d =\u003e d.name.split(\"\\\\.\")).collect() should be(Seq(\"a\", \"b\", \"c\", \"d\")) } } ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:2:0","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"3. 在 Java8 中的使用 其实在 Java8 中没有这么花式的玩法，Option有单独的 flatMap （scala的Option其实也有flatMap，不细说了） ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:3:0","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"3.1. steam 中的 flatMap 方法： package java.util.stream; \u003cR\u003e Stream\u003cR\u003e flatMap(Function\u003c? super T, ? extends Stream\u003c? extends R\u003e\u003e mapper); 返回值仍然是流，比较简单 示例： @Test public void testStream(){ List\u003cList\u003cString\u003e\u003e demo = Arrays.asList( Arrays.asList(\"a\",\"b\"), Arrays.asList(\"c\",\"d\")); List\u003cString\u003e result = demo.stream() .flatMap(Collection::stream) .collect(Collectors.toList()); result.forEach(System.out::print); } ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:3:1","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"3.2. Optional 中的 flatMap 方法： package java.util; public\u003cU\u003e Optional\u003cU\u003e flatMap(Function\u003c? super T, Optional\u003cU\u003e\u003e mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Objects.requireNonNull(mapper.apply(value)); } } 这个更简单，基本没啥说的 示例： @Test public void testOptional(){ Optional\u003cString\u003e demo1 = Optional.of(\"demo\"); Optional\u003cString\u003e result1 = demo1.flatMap(d -\u003e Optional.of(d + \" is not null\")); Assert.assertEquals(result1.orElse(\"\"), \"demo is not null\"); Optional\u003cString\u003e demo2 = Optional.empty(); Optional\u003cString\u003e result2 = demo2.flatMap(d -\u003e Optional.of(d + \" is not null\")); Assert.assertEquals(result2.orElse(\"\"), \"\"); } 好处是可以嵌套使用 ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:3:2","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"4. 结语 就到这里吧，最近状态不太好，正在纠结些问题，反正水帖子，能看就行 ","date":"2020-04-30","objectID":"/2020/04/2020-04-30-flatmap/:4:0","tags":["spark"],"title":"flatMap 在 Scala(Spark)/Java8 中的使用","uri":"/2020/04/2020-04-30-flatmap/"},{"categories":["技术"],"content":"以前写过直接在windows下安装打包好的安装包 详见这里，这种方式依赖过多，安装时可能或多或少影响现在的环境。这次直接用 docker-machine 安装，很大程度上避免这些问题。 ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:0:0","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"环境准备 Windows 环境 Oracle VM VirtualBox Git LInux环境（编译客户端用，如果能找到客户端就不用编译了） ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:1:0","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"Docker-machine 安装 可以按官网说明安装，用 git bash 运行 $ if [[ ! -d \"$HOME/bin\" ]]; then mkdir -p \"$HOME/bin\"; fi \u0026\u0026 \\ curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-Windows-x86_64.exe \u003e \"$HOME/bin/docker-machine.exe\" \u0026\u0026 \\ chmod +x \"$HOME/bin/docker-machine.exe\" 此处可把 $HOME/bin/ 路径添加到环境变量 用下面方法查看是否可用 docker-machine --version ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:2:0","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"Docker 客户端获取 由于docker-machine只是创造了docker虚拟机环境，还需要本地有个docker客户端。下载好对应版本，复制文件到 $HOME/bin/ 并改名为 docker.exe ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:3:0","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"直接下载编译好的 直接从这里下载，但是不一定是最新版本 https://github.com/StefanScherer/docker-cli-builder ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:3:1","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"源码编译 由于使用的 makefile 推荐使用linux编译 git clone 源码 checkout 到想要编译的版本，执行下面语句或看源码说明编译 make -f docker.Makefile cross 这样在当前文件夹下会生成build文件夹，build文件夹中会有 docker、docker-linux-amd64、docker-windows-amd64 等一些文件，其中docker-windows-amd64就是windows中要使用的docker文件。 拷贝出 docker-windows-amd64 文件到 $HOME/bin/ 并改名为 docker.exe 执行 docker –version 查看是否部署成功 ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:3:2","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"创建前配置 可在环境变量中设置 MACHINE_STORAGE_PATH 来指定默认环境生成地点 ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:4:0","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"Docker-machine 创建 以下环境都在 git bash 下运行 ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:5:0","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":["技术"],"content":"virtualbox 创建 docker-machine create --driver virtualbox default 过程中需进行几次权限认证 查询已有的 docker 情况（版本号和创建时相关） docker-machine env [如果不是default，这里需写上名称] 显示相关信息 此时如果在 git bash下执行提示中的语句，则在本进程中docker可用，但是重新打开的话需要重写。比较好的方式是直接写到环境变量中。 这样在 git bash 或 powershell 中都可使用 测试 docker images 即可查看现有 images ","date":"2019-08-21","objectID":"/2019/08/2019-08-10-docker-machine-on-windows/:5:1","tags":["docker"],"title":"在windows上使用dockermachine创建docker","uri":"/2019/08/2019-08-10-docker-machine-on-windows/"},{"categories":null,"content":"1. 兴趣爱好 绘画 摄影 电子产品 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"2. 学习工作相关 GIS专业，毕业后一直从事GIS相关开发工作 主要工作经历： GIS相关三维 地理编码 空间大数据处理 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"2.1. 目前工作 目前主要从事大数据相关工作 主要包括： Spark（Scala）开发 CDH、HDP等相关大数据环境维护 空间大数据相关的研究 其他一些后端开发工作（Java Python等） 希望能和大家一起学习交流 ","date":"2019-08-02","objectID":"/about/:2:1","tags":null,"title":"About","uri":"/about/"},{"categories":["技术"],"content":"最近一段时间很忙，没空写东西。今天整理一下Gitlab flow相关的东西，都是个人理解，如有错误，请指正。 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:0:0","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"Gitlab flow 介绍 懒得细写了，大家直接看这里吧：官方介绍 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:1:0","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"重要特点 分支主要有主分支（master）、功能分支、发布分支组成 master为保护分支，只有主程序员或所有者有权限修改 如果有修改需从主分支分出一个分支，修改完成后再由主程序员合并到主分支中 发布为由上至下发布，即为主分支把需要修改的部分挑选出重要的合并到发布分支中 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:1:1","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"建议 不到必要时不要建立发布分支，减少修改 提交内容细化，定位要精确， 提交要按一定格式，方便查看 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:1:2","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"流程说明 举个栗子： 需在环境中添加某个功能 A，则需要如下操作： 主分支分出一个功能分支，记作 add_a 在 add_a 分支中添加A功能，commit并push到gitlab 创建合并请求 review代码并由主程序员合并到master中 删除Gitlab上的 add_a 分支，防止混乱 接着是发布流程，假设有发布分支 v1，需要把部分新加的功能放到v1中： 检出 v1 分支 执行 cherry-pick 命令，把要添加的commit放到 v1 分支中 提交并发布 v1 分支 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:1:3","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"在IDEA中的使用 使用的IDEA版本为 社区版 2018.3 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:2:0","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"插件安装 Git Commit Template 这个插件可以规范commit格式 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:2:1","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"GitLab环境说明 测试环境中有3个用户，root、devs、maindev 在 maindev 中创建group，并在group中创建工程 gitlabflow，在工程设置中添加devs为开发者 编辑 readme，写上初始版本 添加新分支 v1.0 作为发布分支 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:2:2","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"IDEA操作 打开idea，在开始页面里clone出刚才建立的项目。打开项目后在界面右下角点开 Git: master 选择 New Branch，填写名称 add_a，建立好后，在 README.md 中添加内容 （里面也添加了.gitignore，看着舒服点，不是重点） 执行commit，这里注意，要用到上面提到的插件了 点击模板按钮，按情况填写要提交的内容，具体项目代表的内容及该填什么看这里： angular commit template commit完成后发现原逻辑b有bug，则再从master导出一份分支，fix_b_bug 再次提交 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:2:3","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"Gitlab的合并请求处理 把2个功能分支都push 到 gitlab，登录gitlab，分别提交合并请求 进入主程序员页面，就会发现刚提交的两个请求，比较简单，就直接merge了，merge时会有个冲突，直接修改就可以了，很简单。 merge完成 完成后删除两个功能分支，非特殊情况不要保留已经合并的分支 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:2:4","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"IDEA更新 idea上更新代码，master使用pull即可，本地功能分支在master执行pull后也可删除 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:2:5","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"发布版本 现在模拟这样的情况，在 v1.0 版本中，不添加a功能，只修复b功能bug，可以进行下面的操作，回到IDEA，先把 v1.0 版本clone下来，此时右下角没有 v1.0 可用 Fetch 刷新 在点击右下角的状态，chechout 出 v1.0 这时点开git的历史纪录 右击 fix ：修复b功能错误，点击 Cherry-Pick 会自动弹出提交修复，提交即可完成 此时的 v1.0 版本就是想要的结果 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:2:6","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"Gitlab flow 使用总结 功能分支尽量不要有继承关系 和svn或gitflow等发布方向不同，为自master向下，需要注意 提交格式必须规范化，方便查找 提交精度必须要高，少量多次 能想起来的就这么多了，以后有问题再写 ","date":"2019-06-15","objectID":"/2019/06/2019-06-15-gitlabflow_and_idea/:3:0","tags":["gitlab"],"title":"对 Gitlab flow的理解及在IDEA上的使用","uri":"/2019/06/2019-06-15-gitlabflow_and_idea/"},{"categories":["技术"],"content":"夏天到了，天气变热，是时候给笔记本降降温了。几年没拆笔记本，有点手痒（主因） ","date":"2019-06-02","objectID":"/2019/06/2019-06-02-silicone_grease_replace/:0:0","tags":["pc"],"title":"更换硅脂纪录","uri":"/2019/06/2019-06-02-silicone_grease_replace/"},{"categories":["技术"],"content":"1. 准备工作 笔记本（DELL Inspiron 7559） 多头螺丝刀（这个型号的笔记本有六角梅花螺丝） 硅脂（什么牌子就不说了，又没广告费） 硅脂刮刀（撬盖利器） 白纸或几个容器（放螺丝的，省的多零件） ","date":"2019-06-02","objectID":"/2019/06/2019-06-02-silicone_grease_replace/:1:0","tags":["pc"],"title":"更换硅脂纪录","uri":"/2019/06/2019-06-02-silicone_grease_replace/"},{"categories":["技术"],"content":"2.拆机 一般笔记本的结构大同小异，不过有些暗扣会比较麻烦，还好这个型号比较好拆 ","date":"2019-06-02","objectID":"/2019/06/2019-06-02-silicone_grease_replace/:2:0","tags":["pc"],"title":"更换硅脂纪录","uri":"/2019/06/2019-06-02-silicone_grease_replace/"},{"categories":["技术"],"content":"D面 先把后盖拆下，前几天清过灰了，比较干净 拆电源 能看到的并且能拆的螺丝全部拆下来，我都放到了纸上 这里要注意记一下网卡的接口 拆电池时需要用到六角梅花的头 拆完基本是这个样子： ","date":"2019-06-02","objectID":"/2019/06/2019-06-02-silicone_grease_replace/:2:1","tags":["pc"],"title":"更换硅脂纪录","uri":"/2019/06/2019-06-02-silicone_grease_replace/"},{"categories":["技术"],"content":"C面 键盘上面红线圈起的部分千万不要动，下面没藏螺丝……，只有装饰的铁片 先拆键盘，其实这个型号键盘只有暗扣，直接撬下来就好，注意下面的排线 键盘取下后下面有2个螺丝，转下来后，在把能看见的几个排线打开就可以拆c面了。 确定D面的螺丝全部拧下来之后直接用刮刀翘C面，都是暗扣，需小心的一点点取下来。后面也要撬开。 C面打开后的样子，这时候可以直接取下风扇，如果支持清风扇，拆到这里基本就可以了。 这里有个小卡扣，要先轻轻搬开才能取下来 右侧的 CMOS 电池直接拔了 这时主板上已经没有螺丝了，可以慢慢反转过来，可以看到散热片。 螺丝转下来后就是这样的了，一个CPU一个显卡 ","date":"2019-06-02","objectID":"/2019/06/2019-06-02-silicone_grease_replace/:2:2","tags":["pc"],"title":"更换硅脂纪录","uri":"/2019/06/2019-06-02-silicone_grease_replace/"},{"categories":["技术"],"content":"3. 换硅脂 忘拍照片了，直接说吧。硅脂已经干了，不太好清理，我是用棉棒沾着无水酒精擦的。涂硅脂的话，拿刮刀慢慢刮吧，这个散热片实在有点大，怕压不好…… ","date":"2019-06-02","objectID":"/2019/06/2019-06-02-silicone_grease_replace/:3:0","tags":["pc"],"title":"更换硅脂纪录","uri":"/2019/06/2019-06-02-silicone_grease_replace/"},{"categories":["技术"],"content":"4. 组装 反着回去就行，不过有个建议，盖子什么的先别压实，免得哪根线接触不良或忘接了还得拆开。可以用电源线暂时供电，供电时就不要用金属东西乱碰了，以免短路…… 装好后，刚才CMOS拆了，时间穿越了…… 就到这里了，希望能给有类似机型笔记本的同学一点拆机帮助 ","date":"2019-06-02","objectID":"/2019/06/2019-06-02-silicone_grease_replace/:4:0","tags":["pc"],"title":"更换硅脂纪录","uri":"/2019/06/2019-06-02-silicone_grease_replace/"},{"categories":["技术"],"content":" 不了解spark运行方式而写出的app是没有灵魂的 ———— XXX 其实两年前就想写，但是由于比较懒，一直没动笔，今天还是写点吧。顺便练习一下五笔。 ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:0:0","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"1. 环境信息 spark版本：2.4 源码位置 ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:1:0","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"2. Executor 简介 executor为spark的执行单元，主要由driver进行调度。此类主要在包 org.apache.spark.executor 中。 Executor类源码位置 下面是Executor类的注释 /** * Spark executor, backed by a threadpool to run tasks. * * This can be used with Mesos, YARN, and the standalone scheduler. * An internal RPC interface is used for communication with the driver, * except in the case of Mesos fine-grained mode. */ 上面的大意是 executor 支持在线程池中执行 task。它能够支持 mesos，yarn及standalone模式。 用RPC接口和drive端进行连接。 由于没有用过 mesos，最下面说的 fine-grained 模式不知道是什么，有经验的同学可以补充一下 ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:2:0","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"3. Executor 结构 ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:3:0","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"3.1. object private[spark] object Executor { // This is reserved for internal use by components that need to read task properties before a // task is fully deserialized. When possible, the TaskContext.getLocalProperty call should be // used instead. val taskDeserializationProps: ThreadLocal[Properties] = new ThreadLocal[Properties] } 很简单，定义了一个线程内参数，用于记录执行信息。 private[spark] 说明此类只能在spark包内部调用。 ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:3:1","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"3.2. class 3.2.1. 构造函数 private[spark] class Executor( executorId: String, executorHostname: String, env: SparkEnv, userClassPath: Seq[URL] = Nil, isLocal: Boolean = false, uncaughtExceptionHandler: UncaughtExceptionHandler = new SparkUncaughtExceptionHandler) extends Logging { // 省略源码... ... } 同样是spark包内的内部类。 3.2.2. Executor 内部类 主要有2个内部类： 3.2.2.1. TaskRunner class TaskRunner( execBackend: ExecutorBackend, private val taskDescription: TaskDescription) extends Runnable {/*省略源码*/} 主要功能为执行task 3.2.2.2. TaskReaper private class TaskReaper( taskRunner: TaskRunner, val interruptThread: Boolean, val reason: String) extends Runnable { /*省略源码*/ } 监控关闭task用，默认不启用，如果启用需指明 spark.task.reaper.enabled=true ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:3:2","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"3.3. 主要内容 3.3.1. 初始化执行 private val threadPool = { /*省略源码*/ } /*省略源码*/ private val taskReaperPool = ThreadUtils.newDaemonCachedThreadPool(\"Task reaper\") 线程池的创建，threadPool是执行task时的线程池，taskReaperPool 监督正在关闭和取消的task。 private val executorPlugins: Seq[ExecutorPlugin] = { /*省略源码*/ } 获取 spark.executor.plugins 中设置的插件。我目前还没用过这个，就不做进一步的解释了…… private val heartbeater = ThreadUtils.newDaemonSingleThreadScheduledExecutor(\"driver-heartbeater\") private val heartbeatReceiverRef = RpcUtils.makeDriverRef(HeartbeatReceiver.ENDPOINT_NAME, conf, env.rpcEnv) private val HEARTBEAT_MAX_FAILURES = conf.getInt(\"spark.executor.heartbeat.maxFailures\", 60) startDriverHeartbeater() 创建心跳，和 driver 交互 3.3.2. 执行Task入口 def launchTask(context: ExecutorBackend, taskDescription: TaskDescription): Unit = { val tr = new TaskRunner(context, taskDescription) runningTasks.put(taskDescription.taskId, tr) threadPool.execute(tr) } 开启线程执行task ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:3:3","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"3.4. TaskRunner类 task的执行类，主要内容在 run() 方法中 比较重要的源码有： val value = Utils.tryWithSafeFinally { val res = task.run( taskAttemptId = taskId, attemptNumber = taskDescription.attemptNumber, metricsSystem = env.metricsSystem) threwException = false res } { val releasedLocks = env.blockManager.releaseAllLocksForTask(taskId) val freedMemory = taskMemoryManager.cleanUpAllAllocatedMemory() if (freedMemory \u003e 0 \u0026\u0026 !threwException) { val errMsg = s\"Managed memory leak detected; size = $freedMemorybytes, TID = $taskId\" if (conf.getBoolean(\"spark.unsafe.exceptionOnMemoryLeak\", false)) { throw new SparkException(errMsg) } else { logWarning(errMsg) } } /*省略部分源码*/ } 上面执行的源码分2部分 task执行过程 执行完成或错误后的资源释放等 run部分剩下的内容大部分都是状态的更新，内容序列化等内容 val serializedResult: ByteBuffer = { if (maxResultSize \u003e 0 \u0026\u0026 resultSize \u003e maxResultSize) { logWarning(s\"Finished $taskName(TID $taskId). Result is larger than maxResultSize \" + s\"(${Utils.bytesToString(resultSize)}\u003e ${Utils.bytesToString(maxResultSize)}), \" + s\"dropping it.\") ser.serialize(new IndirectTaskResult[Any](TaskResultBlockId(taskId), resultSize)) } else if (resultSize \u003e maxDirectResultSize) { val blockId = TaskResultBlockId(taskId) env.blockManager.putBytes( blockId, new ChunkedByteBuffer(serializedDirectResult.duplicate()), StorageLevel.MEMORY_AND_DISK_SER) logInfo( s\"Finished $taskName(TID $taskId). $resultSizebytes result sent via BlockManager)\") ser.serialize(new IndirectTaskResult[Any](blockId, resultSize)) } else { logInfo(s\"Finished $taskName(TID $taskId). $resultSizebytes result sent to driver\") serializedDirectResult } } 把获得结果和累加器等返回 driver ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:3:4","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"4. 题外话 写的很水，因为打字太费劲，就不多写了，以后再补充。说多了都是泪 … … ","date":"2019-03-23","objectID":"/2019/03/2019-03-23-learning-spark-1/:4:0","tags":["spark"],"title":"spark源码学习（一） —— Executor","uri":"/2019/03/2019-03-23-learning-spark-1/"},{"categories":["技术"],"content":"　Windows下安装docker坑实在时太多，安装完成后其他虚拟机基本上没法用。 VSCode中有docker的插件，正好利用一下。 **注意：**此方法只适用于开发环境 ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:0:0","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"1. 环境需求 Windows环境 安装好的docker，开启2375端口 注：：docker 如何开启2375端口需要根据不同环境的docker分别配置，验证方法为访问 **http://{IP}:2375/info ** 如果返回相应信息，则证明开启成功 ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:1:0","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"2. docker客户端编译 由于docker官网上只有 docker-ce 桌面版的安装包，需要编译一下客户端。 ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:2:0","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"2.1. 编译准备 下载源码，下面的路径是v18.09版本的，如果有新版本可按需下载源码。 docker客户端源码位置 源码解压到docker服务器机器的root目录下，目录为 /root/cli-18.09.0（这里可按需放置） ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:2:1","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"2.2. 编译客户端 进入到cli-18.09.0目录，执行下面语句： make -f docker.Makefile binary-windows docker编译会自动下载需要的依赖，编译还算比较快，大概几分钟就可以（这里得看网络速度） 过程中可能会出现由于权限问题不能读取 ./scripts/xxx 的情况，可以直接把 ./scripts 的权限改成 o+rwx 编译完成后会在 ./build 文件夹下生成 docker-windows-amd64 文件，拷贝到windows上，修改名称为docker.exe ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:2:2","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"2.3. 编译后文件下载 编译后的 docker.exe 我放到了网盘，不想编译的可以直接下载 docker.exes 下载 提取码：ersy ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:2:3","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"3. Windos配置 ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:3:0","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"3.1. docker环境配置 在环境变量中添加 DOCKER_HOST ，值为： tcp://{IP}:2375 IP按需写 把刚才的docker.exe放到环境变量的path中 在cmd中执行 docker info 命令，如果能返回server的信息，则证明配置成功。 ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:3:1","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"3.2. 配置VSCode 搜索安装docker插件 ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:3:2","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["技术"],"content":"3.3. 测试执行 dockerfile 在VSCode中添加文件夹（为了好整理） 按 Shift + Ctrl + P 选 add docker file 由于是测试，都用默认参数即可 点右键选择 buildimage docker就可以直接在VSCode中进行管理了。 注： VSCode中的Docker插件也有类似 DOCKER_HOST 的配置，但是那个配置不能写 tcp://，只写ip和端口即可。 ","date":"2019-01-06","objectID":"/2019/01/2019-01-06-vscode-docker-windows/:3:3","tags":["docker"],"title":"Windows上用VSCode远程Docker","uri":"/2019/01/2019-01-06-vscode-docker-windows/"},{"categories":["旅行"],"content":"　今年十一去了西安旅游一周，感受了一下十三朝古都的魅力。照的照片相机里都快塞不下了 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:0:0","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"1. 相关行程 时间： 2018-9-30 ~ 2018-10-7 共7天 交通： 高铁 花费： 暂时没算 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:1:0","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2. 过程 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:0","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.1. 九月三十日 　下午坐高铁到西安，时间太晚了，直接入住酒店，途中路过华山，远望了一下 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:1","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.2. 十月一日 　早上吃的回民的胡辣汤，肉夹馍，味道不错。然后去了西安钟楼鼓楼。钟楼是中心，鼓楼没在中轴线，在钟楼偏西，和北京的不太一样。然后去碑林博物馆附近的街道转了圈，走到了南门（永宁门），上了城墙，走了一段，在含光门下来。含光门有个博物馆，里面正在展览，展览名称叫“和合之美”,里面有很多古代的精巧盒子。中午去回民街副街吃了牛肉泡馍，手掰半个多小时，手指甲疼啊……。下午去了大雁塔，当年玄奘译经的地方，傍晚看了音乐喷泉，很壮观。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:2","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.3. 十月二日 　去了西安的东线，主要游览骊山、华清池、兵马俑，人暴多。 早上一大早去火车站坐专线的公交车，比较便宜，发车也比较快。先到的华清宫（华清池+骊山），本来想找电子导游器，不过没找到。先坐缆车上山，上面有鸟语林，竟然有孔雀和鸵鸟。山上还有其他一些景点。下山去了华清池。转了大概半天。下午去的兵马俑，兵马俑有电子导游，租金30，押金100。兵马俑的票包括兵马俑和地宫两个景点的，时间不够，就没去地宫那边。去兵马俑的人实在太多了，挤啊，一号坑人最多，排很长时间才看到了传说中的兵马俑。然后二号坑，三号坑，东西都不算多。晚上10点才回西安。去地时候一人一座，回来挤满了一车人，很闷。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:3","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.4. 十月三日 　去了大唐芙蓉园，地方比较大，休闲式的转了一天，演出很多，不知道日常就那么多还是因为十一的关系。下午就出来了（其实该下午转，晚上看夜景，大唐芙蓉园晚上24点才闭园）。然后去钟鼓楼看夜景。夜景很漂亮，不过遗憾的是没拿三脚架，夜景拍的不怎么样…… ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:4","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.5. 十月四日 　去的西安的西线，人比东线少点。西线的景点特点是景点分散。原本计划租车去乾陵，不过由于没租车经验，最后还是报的一日游。线路是： 汉景帝的汉阳陵 -\u003e 乾陵 （包括懿德太子墓）-\u003e 宝鸡的法门寺。报团的好处是有导游，可以了解很多知识。 阳陵据介绍是唯一开放陪葬坑的景点，陪葬坑上铺的玻璃，可以看到下面的各种俑，器物等，地方不大，很快就转完了。 然后去的乾陵景区的懿德太子墓，乾陵是当地村民自己管理的景区，有历史原因。懿德太子墓比较出名的是上过国家宝藏的壁画。现在在陕西历史博物馆里，应该是在壁画馆，票价比较贵，没看到真迹。随后去的乾陵，见到了以前在电视里看到的无字碑，无字碑现在已经被历代文人墨客刻满了字，当然，也有一些不道德游客刻的。另一侧是述圣纪碑（七节碑），由于时间太长，上面的金子已经模糊不清了。 最后去了法门寺，原本不在计划之内，可能是与佛有缘吧。这次去看到了释迦摩尼的佛骨舍利，听到了关于真身舍利的传奇故事。 回酒店又是10点以后了，这天的旅行比较特殊，几乎没怎么拍照。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:5","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.6. 十月五日 　上午去的大明宫遗址。主要景点是博物馆，讲了唐代的历史。园区不小，有环线车，能很快转玩。下午去的小雁塔，现在是西安博物馆的一部分，用身份证换票就可以进入，院子里人多，但是显得很幽静。晚上去的大雁塔南面的大唐不夜城，有音乐学院的老师学生演奏各种乐器，很是享受，听小提琴演奏小夜曲，很优美。夜景灯光也很漂亮。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:6","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.7. 十月六日 　西安旅行的最后一天去的陕西历史博物馆，排队出了名的长。早上7点到的，结果已经排出很长队了，据说前面的早上4点就来排队了。排队时有很多贩卖地图，相册的，比较有意思。排到9点多，才进到馆里，租了电子导游，也是30租金，100押金。它的电子导游和其他地方的不太一样，需要自己输入在展牌边上的号码。不过内容很丰富。 游览时先去的6展馆，展览的各种雕刻的玉器（大部分是近现代的），很是漂亮。然后按 1-3 展馆看相关展品。按历史排的，相当丰富。很精彩。最后去4展馆看大唐遗宝馆，看到了镇馆之宝“镶金兽首玛瑙杯”，很是漂亮。转到了快下午，直接回酒店休息。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:7","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"2.8. 十月七日 　早上坐车回北京，一大早西安地铁还没开，只能打车了。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:2:8","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"3. 简单总结 　这次旅行很充实，提前一个月计划的。走路比较多，最好穿合适的鞋子（我穿的登山鞋，鞋底那个硬啊，走路比较累）。西安主要是文化旅游，条件允许最好找导游或电子导游。不然只能是走马观花。 ","date":"2018-10-14","objectID":"/2018/10/2018-10-14-tourism-xian/:3:0","tags":["生活"],"title":"2018年十一西安旅游","uri":"/2018/10/2018-10-14-tourism-xian/"},{"categories":["旅行"],"content":"　8月请假去草原自驾游了一圈，景色很漂亮。天气预报报着一直有雨，不过实际天气还不错，最多阴天。 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:0:0","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["旅行"],"content":"1. 相关行程 时间： 2018-8-14 ~ 2018-8-18 共5天 交通： 自驾 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:1:0","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["旅行"],"content":"2. 过程 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:2:0","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["旅行"],"content":"2.1. 第1天 8月14日 　早上爸妈在家出发，中午在北京接我。一路向北，傍晚到达赤峰，住酒店休息。 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:2:1","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["旅行"],"content":"2.2. 第2天 8月15日 　上午出发去玉龙沙湖，大概中午到达。玉龙沙湖主要是红山文化，在这里出土了中华第一龙。景区内有山有水，有草原有沙漠。先坐景区内的车到了沙山，爬了上去，沙子很细。可能前几天下雨，沙子稍微有些潮。有很多滑沙的，不过由于沙子有些潮，效果好像不好。沙山回来后又坐小火车绕湖一周，景色也不错。 玩到下午继续往北走，到了赤峰北面的林西县休息一晚。 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:2:2","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["旅行"],"content":"2.3. 第3天 8月16日 　早上出发去阿斯哈图石林景区，路过黄岗梁。早上天气有点阴，雾有些大。中午才好些。石林景区的石头都很有特色，值得一看。以前以为石林景区的那些石头是沉积岩，后来才知道，那些都是花岗岩。 大概快下午，往达里湖方向开，路过贡格尔草原。贡格尔草原的草不高，地势较为平坦，能看很远，经常有牛羊在马路上穿过。晚上住宿在达里湖南岸景区附近的旅店，吃了当地特色的鱼。晚上这边比较冷。 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:2:3","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["旅行"],"content":"2.4. 第4天 8月17日 　天气阴，有点下雨，到了达里湖。达里湖全称是达里诺尔湖，据说达里湖正在逐年缩小，估计若干年后就看不到了。景区内得坐火车上山，能看的很远。 下午到了乌兰布统旅游区，票可以用3天，晚上就住在了景区里面，顺便看了一下草原的夜景。刚好赶上草原音乐节，人很多。 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:2:4","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["旅行"],"content":"2.5. 第5天 8月18日 　天气很好，开车转了里面的影视基地，将军泡子，还有其他的一些景点。视野开阔，很漂亮。有点经典的xp桌面的感觉了。 下午准备往回返，穿过塞罕坝，堵车有点严重。海拔一直在降低，感觉明显的是气压一直在变。晚上住在承德，算是结束了这次的行程。 ","date":"2018-08-15","objectID":"/2018/08/2018-08-18-tourism-chifeng/:2:5","tags":["生活"],"title":"2018年8月草原自驾游","uri":"/2018/08/2018-08-18-tourism-chifeng/"},{"categories":["技术"],"content":"　scala中没有原生的类似 java 7+ 中的 try(){}catch{} 自动关闭资源的方法。想用的话只能自己写了。 PS: 以前没注意过，shapeless功能真很强大。 　资料不好找啊，网上大部分能搜索到的方法是 参考1 中的方法，比较直接，但是有一个问题，不能实现同时对多个资源close。后来努力寻找，翻到了 参考2 ，不过也存在一些问题，例如在资源关闭时出错的话会直接忽略。 于是整合了一下，有了以下的逻辑： 　注意: 单个和多个必须分开处理 package per.wjh.utils import shapeless._ import ops.hlist._ import ops.nat._ import scala.util.control.NonFatal import scala.util.{Failure, Try} object TryWith { def apply[C \u003c: AutoCloseable, R](resource: =\u003e C)(f: C =\u003e R): Try[R] = Try(resource).flatMap(resourceInstance =\u003e { try { val returnValue = f(resourceInstance) Try(resourceInstance.close()).map(_ =\u003e returnValue) } catch { case NonFatal(exceptionInFunction) =\u003e try { resourceInstance.close() Failure(exceptionInFunction) } catch { case NonFatal(exceptionInClose) =\u003e exceptionInFunction.addSuppressed(exceptionInClose) Failure(exceptionInFunction) } } }) def apply[C, Len \u003c: Nat, L \u003c: HList, R](resources: =\u003e C)(f: C =\u003e R)( implicit gen: Generic.Aux[C, L], con: ToList[L, AutoCloseable], length: Length.Aux[L, Len], gt: GT[Len, nat._1] ): Try[R] = { Try(resources).flatMap(resourceInstance =\u003e try { val returnValue = f(resources) Try(gen.to(resourceInstance).toList.reverse.foreach(_.close())) .map(_ =\u003e returnValue) } catch { case NonFatal(exceptionInFunction) =\u003e try { gen.to(resourceInstance).toList.reverse.foreach(_.close()) Failure(exceptionInFunction) } catch { case NonFatal(exceptionInClose) =\u003e exceptionInFunction.addSuppressed(exceptionInClose) Failure(exceptionInFunction) } } ) } } 　下面简单测试一下： package per.wjh.utils.test import java.io.Closeable import org.scalatest.FunSuite import per.wjh.utils.TryWith import scala.util.{Failure, Success} class TryTest extends FunSuite { case class Closeable1() extends Closeable { def info(): Unit = { println(\"print 1\") } override def close(): Unit = { println(\"close 1 \") } } case class Closeable2() extends Closeable { def info(): Unit = { throw new Exception(\"error in 2\") println(\"print 2\") } override def close(): Unit = { println(\"close 2 \") } } test(\"测试Try\") { TryWith(Closeable1(), Closeable2()) { case (a, b) =\u003e a.info() b.info() \"success\" } match { case Success(value) =\u003e println(value) case Failure(e) =\u003e println(e.getMessage) } println(\"#######################\") } test(\"测试Try2\") { TryWith(Closeable2()) { a =\u003e a.info() \"success\" } match { case Success(value) =\u003e println(value) case Failure(e) =\u003e println(e.getMessage) } println(\"#######################\") } } 　测试结果： print 1 close 2 close 1 error in 2 ####################### close 2 error in 2 ####################### 　Closeable 继承自 AutoCloseable，好玩儿吧？这里用 AutoCloseable适用性更广。 还有，参考2中的关闭顺序有问题，我在上面的新代码中添加了倒序处理。 参考： https://gist.github.com/dmyersturnbull/37f85b7703ea07f5cf88d614a32c98b8 https://dzone.com/articles/simple-try-with-resources-construct-in-scala ","date":"2018-08-09","objectID":"/2018/08/2018-08-09-scalatrywithsource/:0:0","tags":["scala"],"title":"scala try with resource 方法","uri":"/2018/08/2018-08-09-scalatrywithsource/"},{"categories":["旅行"],"content":"　今天水一次，去了趟北京植物园，天气不是特别好，重度污染，下点小雨，不过人相当多！！！ 第一次上传照片太大了，平均3M往上，打开网页都费劲，后来把照片压缩了一下，才好些 　园子里很多花都开了，只顾了花拍照了，忘了记下名字，以下花的名称都是识别软件识别的，不保证准确………… 从南门进去的，今年没买年票，得临时掏腰包了，还好支持交通卡入园，不用去窗口排队。最重要的是去公园买一张票总是收到售票员奇怪的目光。 沿着大路走，人很多，路边的花很抢眼。 **勋章菊：**花的形状特别规则，特别显眼，给人印象深刻。 **角堇：**又名三色堇，极像蝴蝶深浅搭配，很漂亮。 **雏菊：**菊科植物，花很小，不明白是菊科植物为啥夏天开？？ **细叶美女樱：**我不太确定是不是这个名字，花瓣感觉很平，像不像抠图出来的？？ 满树的松塔很好看，不过拍照技术有限，没实景好 **郁金香：**郁金香已经打开了，和含苞待放的那种完全两个风格 　布局很烂，纯粹是为了好玩。 　紫色的确实不一样。 **鸡树条：**很奇怪的名字，不过花很好看，像是个小型花园。 **琼花：**满树都是白饭团子。中午没吃饭，已经饿了 **大花葱：**葱！这货居然是葱，太颠覆我的认知了！！！ 　现在牡丹开的正旺，有的已经开败了，倒是芍药看着这几天就要开了。 　白牡丹啊…… 　这个开的好 　红色的喜庆 　最后上一张樱桃沟的，樱桃沟一部分栈道正在修，水杉依旧那么笔直，不过有了叶子看着没那么明显了，还是喜欢冬天的水杉。 　今天天气不太好，重度污染，基本转了一圈就往回走了，没再去别处。 ","date":"2018-05-05","objectID":"/2018/05/2018-05-05-tourism-bjzwy/:0:0","tags":["生活"],"title":"18年5月5日游北京植物园","uri":"/2018/05/2018-05-05-tourism-bjzwy/"},{"categories":["技术"],"content":"　由于有正式版的win10 home许可，不想升级专业版或其他的了，于是测试在win10 home版下安装docker **注意：**本安装只适用于不想升级home版的，非home版可直接安装 docker for windows，这也是官方推荐的。 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:0:0","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"1. 准备 　按照git和virtualbox为非必选，因为toolbox也自带一套，不过想单独使用git或virtualbox的话建议单独安装。 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:1:0","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"1.1. 安装git 　docker必须安装 git下载地址 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:1:1","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"1.2. 安装 virtualbox 　由于win10 home版本没有Hyper，这里需要安装virtualbox 　virtualbox下载地址 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:1:2","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"1.3. 安装 dockertoolbox 　现在docker官网上直接下载的 docker for windows 是需要高级的windows版本的（应用了Hyper,home版不支持）。win10或其他windows的home版系统只能通过docker toolbox安装 　toolbox下载地址 　安装时可选（如果上面没有安装git和virtualbox，这里可以选上） ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:1:3","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"2. 配置 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:2:0","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"2.1. 初始化 　按照完毕后桌面上会出现快速启动的图标 　如果git没有按默认安装到c盘，这里会启动错误，需修改这个快捷方式的属性。 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:2:1","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"2.2. 修改源 　找到 C:\\Users{用户名}.docker\\machine\\machines\\default\\config.json 　找到 RegistryMirror，添加 \"RegistryMirror\": [ \"https://docker.mirrors.ustc.edu.cn/\" ] 　重启系统 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:2:2","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"2.3. docker启动 　双击运行快速启动，第一次启动会更新文件，反应会比较慢，或者失败，可以再试一次，再不行的话可以去直接找国内镜像。 　docker启动后会出现鲸鱼的标志 　这时就可以对docker进行操作了，如果需要直接在cmd下操作，还需在环境变量里添加下面内容 项目 值 DOCKER_HOST tcp://192.168.99.100:2376 DOCKER_CERT_PATH C:\\Users{这里改成用户名}.docker\\machine\\machines\\default DOCKER_TLS_VERIFY 1 DOCKER_MACHINE_NAME default 　这时，cmd或powershell里面直接运行了。 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:2:3","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"3. VSCode管理Docker 　VSCode是个神奇的东西，这个竟然也能维护。 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:3:0","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"3.1. 安装插件 　首先要安装插件，直接在扩展里搜索docker，直接安装即可。 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:3:1","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"3.2. 建立dockerfile 　确定能正常连接后可用插件建立dockerfile。 按 F1 键,输入docker add docker files to workspace, 这里提供了几个模板，部署用的，这里测试，做个helloworld，用other就可以了。后面输入ip，我这里改成8000。 　修改Dockerfile，写简单点 FROM hello-world LABEL Name=helloworld Version=0.0.1 　在dockerfile上右击，选择buildimage，helloword会直接下载。 　完成后右击新建的image，选择 run interactive 　下面的终端会显示 PS D:\\Docker\\helloworld\u003e docker run --rm -it helloworld:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/ For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ PS D:\\Docker\\helloworld\u003e 　基本完成部署。 ","date":"2018-01-20","objectID":"/2018/01/2018-01-20-dockeronwin10/:3:2","tags":["docker"],"title":"Docker在win10 home版下安装","uri":"/2018/01/2018-01-20-dockeronwin10/"},{"categories":["技术"],"content":"　现在很多框架都是自动配置，方便了许多，但是也因此带来了麻烦。例如一些特殊的情况下，自动完成的不能满足需求。Jackson也有类似的问题，这时就需要自定义格式化类型。 　实际操作中有这样一个问题，postgresql较新的版本支持json格式，当数据库中有jsonb或json字段时，用mybatis等框架读取出来的并不是json字符串，而是PGData的格式，这时就需要进行数据的格式化了。 　首先模拟出一个PGData /** * 模拟Postgresql中传入的jsonb */ public class PGData { private String type; private Object value; public String getType() { return type; } public void setType(String type) { this.type = type; } public Object getValue() { return value; } public void setValue(Object value) { this.value = value; } } 简单演示，方法和测试就都写在一起了。 import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.BeanPropertyWriter; import com.fasterxml.jackson.databind.ser.BeanSerializerModifier; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.List; public class JacksonModifier { // 添加时间及pgdata修改内容 private static final ObjectMapper objectMapper = new ObjectMapper(); // 不添加任何内容，做对比用 private static final ObjectMapper objectMapper1 = new ObjectMapper(); static { // 添加修改 objectMapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\")) .setSerializerFactory(objectMapper.getSerializerFactory().withSerializerModifier(getJsobModifier())); } /** * 获取 修改类的实例 * @return */ private static BeanSerializerModifier getJsobModifier() { return new BeanSerializerModifier() { @Override public List\u003cBeanPropertyWriter\u003e changeProperties(SerializationConfig config, BeanDescription beanDesc, List\u003cBeanPropertyWriter\u003e beanProperties) { for (BeanPropertyWriter w : beanProperties) { if (w.getType().getRawClass().equals(PGData.class)) { w.assignSerializer(new JsonSerializer\u003cObject\u003e() { @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeObject(((PGData) value).getValue()); } }); } } return beanProperties; } }; } public static void main(String[] args) { try { TestData td = new TestData(); td.setDt(new Date()); PGData pgdt = new PGData(); pgdt.setType(\"jsonb\"); pgdt.setValue(\"value\"); td.setPgData(pgdt); System.out.println(\"修改后\"); System.out.println(objectMapper.writeValueAsString(td)); System.out.println(\"原始输出\"); System.out.println(objectMapper1.writeValueAsString(td)); } catch (JsonProcessingException e) { e.printStackTrace(); } } } 　最近写scala有点多，成习惯了，getJsobModifier方法直接串下来了…… getJsobModifier方法生成转换的实例会把type去掉，只留下value，作为最终结果。 　测试输出： 修改后 {\"dt\":\"2018-01-13 08:04:07\",\"pgData\":\"value\"} 原始输出 {\"dt\":1515845047360,\"pgData\":{\"type\":\"jsonb\",\"value\":\"value\"}} 　可以看到时间格式转换和PGData类型的数据都有了改变 ","date":"2018-01-13","objectID":"/2018/01/2018-01-13-jacksonformat/:0:0","tags":["java"],"title":"Jackson自动对类型格式化","uri":"/2018/01/2018-01-13-jacksonformat/"},{"categories":["技术"],"content":"　开年第一篇，写个简单点的。spark中多个Dataset进行union的方式，这种情况并不是太多见，不过也不算少，例如合并多个按时间保存的数据。 ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:0:0","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"1. 不是环境的环境 项目 内容 系统 win10家庭版 spark源码版本 v2.0.2 IDE IDEA社区版 配置 太低，不好意思说 其他 还没想好 　能测试就行，凑合用 ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:1:0","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"2. 搭建测试环境 　用gradle托管，最基础的包即可 group 'pers.wjh.spark.units' version '1.0-SNAPSHOT' apply plugin: 'scala' sourceCompatibility = 1.8 repositories { maven {url \"http://maven.aliyun.com/nexus/content/groups/public\"} } dependencies { testCompile group: 'junit', name: 'junit', version: '4.12' compile \"org.apache.spark:spark-core_2.11:2.0.2\" compile \"org.apache.spark:spark-sql_2.11:2.0.2\" } ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:2:0","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"3. 多个Dataset的union方式 ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:3:0","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"3.1. 基础union 　适合于已知要union的Dataset的个数，简单直接。 val dsAll = ds1.union(ds2).union(ds3) ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:3:1","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"3.2. 递归union 　利用Dataset接口的union方法，进行递归操作 /** * 递归union执行 * @param dsArray 要union的列表 * @param index 位置 * @return */ private def recurUnionGroup(dsArray: Seq[Dataset[Row]], index:Int):Dataset[Row]= if (index \u003c dsArray.length-1) dsArray(index).union(recurUnionGroup(dsArray,index+1)) else dsArray.last 　这里用递归的方式实现上种方法中的连续union，不过这种方法已经可以实现动态的union，虽然方法比较直接。 ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:3:2","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"3.3. 调用Union直接union 　重头戏来了，其实spark里面已经有了多个Dataset进行union的方法，只不过藏的稍微深了点，先上代码实现： /** * 调用Union方法 * @param dsArray * @return */ def unionGroup(dsArray: Seq[Dataset[Row]]):Dataset[Row] = new Dataset(spark,Union(dsArray.map(_.queryExecution.logical)),RowEncoder(dsArray.head.schema)) 　我们可以先看Dataset接口实现的union源码,位置在： spark-2.0.2\\sql\\core\\src\\main\\scala\\org\\apache\\spark\\sql\\Dataset.scala 第 1459 行 def union(other: Dataset[T]): Dataset[T] = withSetOperator { // This breaks caching, but it's usually ok because it addresses a very specific use case: // using union to union many files or partitions. CombineUnions(Union(logicalPlan, other.logicalPlan)) } 　这里调用了Union方法，其实Union还有一个实现,可以执行多Dataset的union /** Factory for constructing new `Union` nodes. */ object Union { def apply(left: LogicalPlan, right: LogicalPlan): Union = { Union (left :: right :: Nil) } } case class Union(children: Seq[LogicalPlan]) extends LogicalPlan { override def maxRows: Option[Long] = { if (children.exists(_.maxRows.isEmpty)) { None } else { Some(children.flatMap(_.maxRows).sum) } } // 这里省略一些...... } 　不过也可以看到，这里的参数是LogicalPlan，而不是Dataset，由于只是Dataset的union，我们之间找到dataset初始化时的LogicalPlan即可，LogicalPlan在Dataset里是私有字段，只好去找初始化时的queryExecution了。 Union完成后得到了新的LogicalPlan，再用这个LogicalPlan执行生成新的Dataset，即为需要的union完成后的Dataset。 ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:3:3","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"4. 测试 　用单元测试进行简单的显示： @Test def testRecurUnion():Unit={ println(\"递归union结果：\") val dsList = Seq(ds1,ds2,ds3) val multiUnion = MultiUnion(spark) multiUnion.recurUnionGroup(dsList).show() } @Test def testBase():Unit={ println(\"依次union结果：\") val dsAll = ds1.union(ds2).union(ds3) dsAll.show() } @Test def testUnion():Unit={ println(\"调用union类结果：\") val dsList = Seq(ds1,ds2,ds3) val multiUnion = MultiUnion(spark) multiUnion.unionGroup(dsList).show() } 　输出结果： spark方法调用union结果： +---+-----+ | id|value| +---+-----+ | 1| a| | 2| b| | 3| c| | 4| d| | 5| e| | 6| f| +---+-----+ 依次union结果： +---+-----+ | id|value| +---+-----+ | 1| a| | 2| b| | 3| c| | 4| d| | 5| e| | 6| f| +---+-----+ 递归union结果： +---+-----+ | id|value| +---+-----+ | 1| a| | 2| b| | 3| c| | 4| d| | 5| e| | 6| f| +---+-----+ ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:4:0","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"5. 其他说明 　由于spark都是lazy执行，这几种方法在执行效率上差异并不明显。 　源码详见 ：Union类 及 测试 ","date":"2018-01-12","objectID":"/2018/01/2018-01-12-sparkunion/:5:0","tags":["spark"],"title":"Spark中多个Dataset进行union操作的方法","uri":"/2018/01/2018-01-12-sparkunion/"},{"categories":["技术"],"content":"　从头部署jetty比较麻烦，这里写了一个安装jetty的脚本，可以比较快速的部署jetty。 ","date":"2017-08-16","objectID":"/2017/08/2017-08-16-jettyinstaller/:0:0","tags":["java"],"title":"Jetty安装脚本","uri":"/2017/08/2017-08-16-jettyinstaller/"},{"categories":["技术"],"content":"主要功能 创建用户及组 解压jetty 配置程序与工作目录分离 自动复制配置文件及需要信息到工作目录 添加服务到自启动（centos系统，ubuntu等系统需自己改，很简单） ","date":"2017-08-16","objectID":"/2017/08/2017-08-16-jettyinstaller/:1:0","tags":["java"],"title":"Jetty安装脚本","uri":"/2017/08/2017-08-16-jettyinstaller/"},{"categories":["技术"],"content":"自己配置 端口等配置须自己设置 防火墙各个系统的不一样，须自己开端口 ","date":"2017-08-16","objectID":"/2017/08/2017-08-16-jettyinstaller/:2:0","tags":["java"],"title":"Jetty安装脚本","uri":"/2017/08/2017-08-16-jettyinstaller/"},{"categories":["技术"],"content":"脚本主体 #!/bin/bash echo \"安装jetty\" ################################################## # 参数设置 ################################################## # 安装目录 installPath=/opt/apps/jetty # 工作目录 JETTY_BASE=/opt/jettyWebs USER=jetty GROUP=jetty # 压缩包路径，tar.gz包 JettyPath=jetty-distribution-9.4.6.v20170531.tar.gz ################################################## # 公共方法 ################################################## function exitInfo() { echo \"退出 ： $1\" exit 0 } function createUser() { egrep \"^$GROUP\" /etc/group \u003e\u0026 /dev/null if [ $? -ne 0 ] then echo \"添加用户组$GROUP\" groupadd $GROUP fi egrep \"^$USER\" /etc/passwd \u003e\u0026 /dev/null if [ $? -ne 0 ] then echo \"添加用户$USER\" useradd -g $GROUP $USER fi } function deleteFolder() { if [ -d \"$1\" ]; then rm -rf \"$1\" echo \"删除文件夹: $1\" fi } function createFolder() { if [ ! -d \"$1\" ]; then mkdir -p \"$1\" echo \"创建文件夹: $1\" fi } ################################################## # jetty相关方法 ################################################## function createJettyDic() { createFolder \"$installPath\" createFolder \"$JETTY_BASE\" } function unzipJetty() { jettyFile=${JettyPath##*/} jettyFileName=${jettyFile/%.tar.gz/} tar -xzvf \"$JettyPath\" -C \"$installPath\" 1\u003e/dev/null 2\u003e\u00261 echo \"解压到 $installPath\" lnsPath=$installPath/current rm -f $lnsPath ln -s \"$installPath/$jettyFileName\" \"$lnsPath\" if [ ! -f \"$JETTY_BASE/start.ini\" ]; then cp \"$lnsPath\"/start.ini \"$JETTY_BASE\" fi createFolder \"$JETTY_BASE\"/temp createFolder \"$JETTY_BASE\"/work createFolder /var/run/jetty cp \"$lnsPath\"/demo-base/* \"$JETTY_BASE\" chown -R \"$USER\":\"$GROUP\" \"$installPath\" chown -R \"$USER\":\"$GROUP\" \"$JETTY_BASE\" chown -R \"$USER\":\"$GROUP\" /var/run/jetty usermod -d $JETTY_BASE $USER cp -f \"$lnsPath\"/bin/jetty.sh /etc/init.d/jetty chmod 700 /etc/init.d/jetty echo -e \"JETTY_HOME=$lnsPath\\nJETTY_BASE=$JETTY_BASE\\nTMPDIR=$JETTY_BASE/temp\\nJETTY_USER=$USER\" \u003e /etc/default/jetty # centos自启，其他系统改这里 chkconfig jetty on } if [ \"$(whoami)\" != \"root\" ] then exitInfo \"请用root用户或用 sudo 安装\" fi #添加用户 createUser # 添加文件夹 createJettyDic # 解压jetty unzipJetty ","date":"2017-08-16","objectID":"/2017/08/2017-08-16-jettyinstaller/:3:0","tags":["java"],"title":"Jetty安装脚本","uri":"/2017/08/2017-08-16-jettyinstaller/"},{"categories":["技术"],"content":"　今天测试一下在window上搭建spark环境，此环境只适用于代码测试，实际运行要在集群环境下。 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:0:0","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"基本环境 　我在自己的个人电脑上搭建，环境为 win10 家庭版，内存12G ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:1:0","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"注意事项 本环境搭建目的是测试代码，不做生产环境。 计算机环境内存要够用，不然测试都带不起来。 本环境没有hdfs，只读取本地文件 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:1:1","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"环境搭建 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:2:0","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"下载winutils 　spark需要依赖hadoop的部分内容，github上有winutils文件下载 winutils下载 这个文件不大，大概4.7M，可以都下载下来。 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:2:1","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"配置winutils 　把压缩文件中的 hadoop-2.7.1 解压到某个位置(我用的是这个版本，也可以用其他的，这个和等会儿要下载的spark预编译文件有关系)。 添加环境变量，在windows里添加 HADOOP_HOME 的环境变量，指向刚才复制的文件路径 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:2:2","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"下载spark 　解压文件到某个地址 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:2:3","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"spark测试 　打开cmd，cd到spark的bin目录，执行spark-shell。出现spark版本信息，说明配置基本成功。 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:2:4","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"程序测试 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:3:0","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"编写Scala程序 　此程序段用scala编写，仅供测试；步骤是读取英文小说( 传说中的《时间简史》)，通过空格和标点符号分词，然后进行词频处理，词频排序最后进行输出。 package indi.wjh.spark.testenv import org.apache.spark.SparkConf import org.apache.spark.sql.{SaveMode, SparkSession} object SparkMain { def main(args: Array[String]): Unit = { val spark = SparkSession.builder().config(new SparkConf()).getOrCreate() import spark.implicits._ val wcount = spark.read.text(\"D:\\\\txt\\\\A Brief History of Time.txt\") .as[String].flatMap(_.split(\"[\\\\s+|\\\\p{P}]\")).filter(_.trim != \"\") .groupByKey(_.toLowerCase).count() val wordOrder = wcount.orderBy(wcount(wcount.schema.fields(1).name).desc) //输入成1个文件 wordOrder.repartition(1).write.mode(SaveMode.Overwrite) .csv(\"D:\\\\txt\\\\count.csv\") wordOrder.show() spark.stop() } } 　执行命令 run.bat D:\\services\\spark-2.0.2-bin-hadoop2.7\\bin\\spark-submit2 ^ --master local[*] ^ --name wcount ^ --class indi.wjh.spark.testenv.SparkMain ^ testenv-1.0-SNAPSHOT.jar 完成输出，共 8119行 **注意：**spark在windows上有bug，不能删除临时文件，这个问题暂时没解决，需手动删除。 ","date":"2017-08-13","objectID":"/2017/08/2017-08-13-sparkonwindows/:3:1","tags":["spark"],"title":"Windows系统上spark环境搭建","uri":"/2017/08/2017-08-13-sparkonwindows/"},{"categories":["技术"],"content":"　以前用python写过一些简单的爬虫，没用过框架。一个朋友要爬取api数据，数据量不算太大，不过得用一些递归爬取，这次趁这个机会尝试一下用框架爬取数据。 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:0:0","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"1. Scrapy部署 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:1:0","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"1.1. 环境信息 　用 windows 系统搭建scrapy环境跟麻烦，由于scrapy需要依赖twisted，而twisted只有源码编译，如果系统安装时没有合适的编译环境，则不能正常安装。 于是选择linux作为系统环境，比较方便搭建。环境详情如下： 内容 版本 系统 CentOS Linux release 7.1.1503 python Python 2.7.5 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:1:1","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"1.2. 安装配置 1.2.1. 安装pip 　默认centos中的python是不安装pip的，为了方便，先安装pip wget https://bootstrap.pypa.io/get-pip.py python get-pip.py 　安装完成后用 -V 确认 pip -V 1.2.2. 安装其他环境 　由于需要编译及其他需要，还要安装其他内容 yum install openssl-libs openssl-devel openssl gcc 1.2.3. 安装scrapy pip install scrapy 　这里步骤很简单，但是很容易出错 1.2.4. 安装时易出的问题 　如果twisted未正常安装，需要手动安装时，要注意不要安装最新版本，否则不能正常运行。我在这里用的是16.4.1版本 pip install twisted==16.4.1 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:1:2","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"2. 编写爬取数据逻辑 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:2:0","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"2.1. 建立工程 scrapy startproject spider 　这时，创建了一个名为spider的工程，里面已经有了结构 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:2:1","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"2.2. 查看网页结构 　由于这次是爬取 ArcGIS的api，形势比较规整，提取较为容易。 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:2:2","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"2.3. 创建爬取逻辑 2.3.1. 添加 item 　在./spider/spider/items.py 中创建item，这里主要目的是记录结构 2.3.2. 创建主文件 　在./spider/spiders中创建文件，并编写逻辑 源码详见 github 2.3.3. 配置输出 　这里需要设置 ./spider/spider/pipelines.py class ArcgiswpfPipeline(object): def open_spider(self, spider): self.file = open('items.line-json', 'wb') def process_item(self, item, spider): line = json.dumps(dict(item)) + \"\\n\" self.file.write(bytes(line, encoding = \"utf8\")) return item def spider_closed(self, spider): self.file.close() 　主要是指定输出格式，这里输出成了json，按行输出。 2.3.4. 其他注意点 　这里有几个注意点，方法中 def parse(self, response): 为入口方法，这里主要用了xpath和regex的方式去获取数据。另外，还要遍历左侧的树形列表，这里建立一个set记录已经处理的页，处理过的则不处理。 这里也有xpath的一些技巧，比如需要获取一个节点的全部文字内容，则可以用 m.xpath(“string(.)”).extract()[0]获取。 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:2:3","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"3. 其他优化 　由于ArcGIS在国内服务器访问比较慢，这里需要应用代理。好在scrapy直接能设置代理。 配置一下 ./spider/spider/middlewares.py 　在已有的类里面添加方法 def process_request(self, request, spider): # Set the location of the proxy request.meta['proxy'] = \"http://192.168.1.6:8087\" 　在 ./spider/spider/setting.py 中把 DOWNLOADER_MIDDLEWARES 解除注释，并改成刚改过的类。 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:3:0","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"4. 爬取数据 scrapy crawl arcgis_wpf 　结果数据(1条) { \"class_name\": \"SuggestParameters\", \"class_props\": [ { \"type\": \"Public method\", \"name\": \"SuggestParameters\", \"desc\": \"Creates a new SuggestParameters instance.\" }, { \"type\": \"Public property\", \"name\": \"Categories\", \"desc\": \"Gets a mutable list of categories from which addresses should be returned.\" }, { \"type\": \"Public property\", \"name\": \"CountryCode\", \"desc\": \"Gets or sets a value representing the country. Providing this value increases geocoding speed. Acceptable values include the full country name, the ISO 3166-1 2-digit country code, or the ISO 3166-1 3-digit country code. A list of supported countries and codes is available here.\" }, { \"type\": \"Public property\", \"name\": \"MaxResults\", \"desc\": \"Gets or sets the maximum number of returned suggestions.\" }, { \"type\": \"Public property\", \"name\": \"PreferredSearchLocation\", \"desc\": \"Gets or sets preferred search location.\" }, { \"type\": \"Public property\", \"name\": \"SearchArea\", \"desc\": \"Gets or sets the geographic area for which searching for locations will be limited to.\" } ], \"class_desc\": \"A class representing the parameters to a geocoding suggestion operation.\", \"namespace\": \"Esri.ArcGISRuntime.Tasks.Geocoding\", \"class_type\": \"class\" } 　好了，到这里就结束了。得到这些数据后可以再解析，得到想要的结构。 ","date":"2017-03-10","objectID":"/2017/03/2017_03_10_scrapytest/:4:0","tags":["爬虫"],"title":"Scrapy 爬虫框架初试","uri":"/2017/03/2017_03_10_scrapytest/"},{"categories":["技术"],"content":"　MarkDwon原生不支持table，用扩展的table很简单方便，但是这个table不支持单元格合并。用html可以写出需要的表格，但是写的内容较多且不易维护。 　下面用sublime的OmniMarkupPreviewer插件实现rowspan及colspan。 ","date":"2016-07-02","objectID":"/2016/07/2016_07_02_markdownrowspan/:0:0","tags":["markdown"],"title":"Markdown导出html时rowspan与colspan的处理","uri":"/2016/07/2016_07_02_markdownrowspan/"},{"categories":["技术"],"content":"1. 实现思路 　这里利用的是sublime的OmniMarkupPreviewer插件，利用它导出html。OmniMarkupPreviewer有一个特点是能够运行写在md文件里的javascript，可以利用js对html进行dom操作。 　试过很多markdown工具进行html生成，都不能很好的解析js。所以下面的这个方法并不是通用方法。只适用于利用md文件生成html。 ","date":"2016-07-02","objectID":"/2016/07/2016_07_02_markdownrowspan/:1:0","tags":["markdown"],"title":"Markdown导出html时rowspan与colspan的处理","uri":"/2016/07/2016_07_02_markdownrowspan/"},{"categories":["技术"],"content":"2. 实现过程 　sublime和OmniMarkupPreviewer安装使用就不说了，网上教程很多。下面内容只是实现。 ","date":"2016-07-02","objectID":"/2016/07/2016_07_02_markdownrowspan/:2:0","tags":["markdown"],"title":"Markdown导出html时rowspan与colspan的处理","uri":"/2016/07/2016_07_02_markdownrowspan/"},{"categories":["技术"],"content":"2.1. 添加js脚本 　原理是在html的td中搜索指定标示，然后进行rowspan或colspan的属性填充，最后删除标示。 标示有： rowspan(n) 纵向合并 colspan(n) 横向合并 deltd 删除td，rowspan或colspan覆盖的地方需要用，不然会挤出 　添加代码如下： document.onreadystatechange = function () { if(document.readyState==\"complete\") { var rowspanpat = /##rowspan\\(\\d*\\)##/g; var deltdpat = /##deltd##/g; var colspanpat = /##colspan\\(\\d*\\)##/g; var tds = document.getElementsByTagName(\"td\"); for(var i= 0 ;i\u003ctds.length;i++){ var deltdmatch = tds[i].innerHTML.match(deltdpat); if(deltdmatch \u0026\u0026 deltdmatch[0]){ tds[i].parentNode.removeChild(tds[i]); i--; }else{ span(tds[i], \"rowspan\"); span(tds[i], \"colspan\"); } } } } function span(td, spantype){ var spanpat = null; if(spantype == \"rowspan\"){ spanpat = /##rowspan\\(\\d*\\)##/g; }else{ spanpat = /##colspan\\(\\d*\\)##/g; } var match = td.innerHTML.match(spanpat); if(match \u0026\u0026 match[0]){ td.innerHTML = td.innerHTML.replace(match[0], '') var spanval = match[0].match(/\\d+/g); td.setAttribute(spantype, spanval); } } ","date":"2016-07-02","objectID":"/2016/07/2016_07_02_markdownrowspan/:2:1","tags":["markdown"],"title":"Markdown导出html时rowspan与colspan的处理","uri":"/2016/07/2016_07_02_markdownrowspan/"},{"categories":["技术"],"content":"2.2. 实例效果 js脚本加入到md文件最下面 # 测试 | 测试 | 测试1 | 测试2 | 测试3 | |:----------------|:----------|:----------------|:------| | a | b | c##rowspan(2)## | d | | e##colspan(2)## | ##deltd## | ##deltd## | f | \u003cscript type=\"text/javascript\"\u003e document.onreadystatechange = function () { if(document.readyState==\"complete\") { var rowspanpat = /##rowspan\\(\\d*\\)##/g; var deltdpat = /##deltd##/g; var colspanpat = /##colspan\\(\\d*\\)##/g; var tds = document.getElementsByTagName(\"td\"); for(var i=0;i\u003ctds.length;i++){ var deltdmatch = tds[i].innerHTML.match(deltdpat); if(deltdmatch \u0026\u0026 deltdmatch[0]){ tds[i].parentNode.removeChild(tds[i]); i--; }else{ span(tds[i], \"rowspan\"); span(tds[i], \"colspan\"); } } } } function span(td, spantype){ var spanpat = null; if(spantype == \"rowspan\"){ spanpat = /##rowspan\\(\\d*\\)##/g; }else{ spanpat = /##colspan\\(\\d*\\)##/g; } var match = td.innerHTML.match(spanpat); if(match \u0026\u0026 match[0]){ td.innerHTML = td.innerHTML.replace(match[0], '') var spanval = match[0].match(/\\d+/g); td.setAttribute(spantype, spanval); } } \u003c/script\u003e ","date":"2016-07-02","objectID":"/2016/07/2016_07_02_markdownrowspan/:2:2","tags":["markdown"],"title":"Markdown导出html时rowspan与colspan的处理","uri":"/2016/07/2016_07_02_markdownrowspan/"},{"categories":["技术"],"content":"最近准备用C改一些东西，准备尝试一下LLVM和Clang，正好写一下它的编译。 ","date":"2016-06-15","objectID":"/2016/06/2016_06_15_clangbuild/:0:0","tags":["clang"],"title":"Clang 编译","uri":"/2016/06/2016_06_15_clangbuild/"},{"categories":["技术"],"content":"1. 编译环境 　由于在个人电脑上编译，为了不影响我那几个RPG和时常挂着却一直没动静的QQ，还是暂定用Windows系统编译。由于个人习惯（主要是懒），实在不想装 Visual Studio 那样的巨无霸，干脆直接用MinGW，直接复制粘贴。资源不太好找，墙外下了好几次才下载下来。我放到了我的资源里面，地址：MinGW-W64下载，后加：最近CSDN有点坑，原来我设置的是免积分的，现在自动设成了3个，大家可以用tdm-gcc 　把我现在的编译环境整理一下： 系统：Windows 7 64位 编译器：MinGW-W64-builds-4.2.0 CMake：CMake 3.5.2 下载地址 　MinGW 下载下来后需在环境变量的PATH里加一下。CMake如果是ZIP的话最好也加到PATH里，方便使用。配置方法不难，不再详谈。 ","date":"2016-06-15","objectID":"/2016/06/2016_06_15_clangbuild/:1:0","tags":["clang"],"title":"Clang 编译","uri":"/2016/06/2016_06_15_clangbuild/"},{"categories":["技术"],"content":"2. LLVM源码下载 llvm直接从官网下载即可 llvm源码：http://llvm.org/releases/3.8.0/llvm-3.8.0.src.tar.xz CLang源码：http://llvm.org/releases/3.8.0/cfe-3.8.0.src.tar.xz ","date":"2016-06-15","objectID":"/2016/06/2016_06_15_clangbuild/:2:0","tags":["clang"],"title":"Clang 编译","uri":"/2016/06/2016_06_15_clangbuild/"},{"categories":["技术"],"content":"3. 编译过程 打开cmd，cd到解压后的目录。运行 mkdir build，新建一个build文件夹，这样是为了防止编译内容和源码混乱，以后方便维护。 E:\\SourceCode\\llvm\\llvm-3.8.0.src\u003emkdir build E:\\SourceCode\\llvm\\llvm-3.8.0.src\u003ecd build E:\\SourceCode\\llvm\\llvm-3.8.0.src\\build\u003e 用CMake处理 E:\\SourceCode\\llvm\\llvm-3.8.0.src\\build\u003ecmake -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=D:\\LLVM -DCMAKE_MAKE_PROGRAM=mingw32-make.exe .. 为了方便说明，我把参数拆开，实际用的时候写一行即可。 G为要生成的格式，用MinGW，这里大小写必须写对，写错的话会有提示。 CMAKE_BUILD_TYPE为构建类型，可以写Debug，Release，MinSizeRel。 CMAKE_INSTALL_PREFIX为install路径，一般这里路径最好保守一些，尽量不要用中文或空格。 CMAKE_MAKE_PROGRAM这里写不写都可以。 最后的两点指的是上层路径，按CMake文档，应该写在前面，实际写到后面好像也没什么。 编译LLVM。前面的几步运行的还算快，make就是挑战耐性的时刻了，MinGW用的是mingw32-make，这里很简单，但是是最耗时的，休息一下。这里完成以后，install一下，就能放到CMake设置里的位置了 E:\\SourceCode\\llvm\\llvm-3.8.0.src\\build\u003emingw32-make ………… E:\\SourceCode\\llvm\\llvm-3.8.0.src\\build\u003emingw32-make install 配置编译Clang，步骤和编译LLVM差不多，不细说了，直接上参数 E:\\SourceCode\\llvm\\cfe-3.8.0.src\u003ecmake -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=D:\\LLVM .. E:\\SourceCode\\llvm\\cfe-3.8.0.src\\build\u003emingw32-make E:\\SourceCode\\llvm\\cfe-3.8.0.src\\build\u003emingw32-make install 最后不要忘了把编译输出的路径加到Path里面 ","date":"2016-06-15","objectID":"/2016/06/2016_06_15_clangbuild/:3:0","tags":["clang"],"title":"Clang 编译","uri":"/2016/06/2016_06_15_clangbuild/"},{"categories":["技术"],"content":"4. 测试 打开cmd，输入 clang -v 输出版本 C:\\Users\\wjh\u003eclang -v clang version 3.8.0 (tags/RELEASE_380/final) Target: x86_64-w64-windows-gnu Thread model: posix InstalledDir: D:\\LLVM\\bin 下面用程序测试 test.cpp #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello World!\" \u003c\u003c endl; return 0; } 编译 E:\\test\u003eclang++ -o test.exe test.cpp 运行 E:\\test\u003etest.exe Hello World! ","date":"2016-06-15","objectID":"/2016/06/2016_06_15_clangbuild/:4:0","tags":["clang"],"title":"Clang 编译","uri":"/2016/06/2016_06_15_clangbuild/"},{"categories":["技术"],"content":"5. 编译问题或其他 libcxx和libcxxabi在Windows上编译总有问题，没成功，以后再试，如果有编译成功的望指教。 太穷，买不起Mac，有时间还是在Linux上试试，移植的东西肯定没原装的用着顺。 ","date":"2016-06-15","objectID":"/2016/06/2016_06_15_clangbuild/:5:0","tags":["clang"],"title":"Clang 编译","uri":"/2016/06/2016_06_15_clangbuild/"},{"categories":["技术"],"content":"　JAVA的正则替换用String类里的repalceAll方法就可以实现，但是这个方法有一个不小的缺陷，只能把正则查找出来的内容用同一段内容替换。现在我们要利用appendReplacement写一个以查找内容为参数进行自定义替换内容的方法。 　先写代码，再解释。 1. 代码实现 ","date":"2016-05-28","objectID":"/2016/05/2016_05_28_javaregexexchange/:0:0","tags":["java"],"title":"JAVA做自定义正则替换","uri":"/2016/05/2016_05_28_javaregexexchange/"},{"categories":["技术"],"content":"1.1. 建立抽象类 package util.extregex; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * 扩展替换抽象类 * @author wjh * */ public abstract class AbstractExtReplace { private String regexstr = \"\"; /** * 处理查找出来的数据 * @param word 输入数据 * @return 输出处理后的结果 */ protected abstract String treateWord(String word); /** * 继承方法里可以设置正则表达式 * @param regexstr */ protected void setRegexstr(String regexstr){ this.regexstr = regexstr; } /** * 替换 * @param input 输入内容 * @return */ public String extReplace(String input){ return extReplace(regexstr, input, false); } /** * 替换 * @param input 输入内容 * @param useGroupName 是否用到groupname 默认false * @return */ public String extReplace(String input, Boolean useGroupName){ useGroupName = (useGroupName == null)?false:useGroupName; return extReplace(regexstr, input, useGroupName); } /** * 核心方法，正则替换 * @param regex 输入正则表达式 * @param input 输入查找原始内容 * @param useGroupName 是否用到groupname * @return 返回替换后结果 */ protected String extReplace(String regexstr, String input, Boolean useGroupName){ Pattern p = Pattern.compile(regexstr); Matcher m = p.matcher(input); StringBuffer sb = new StringBuffer(); while (m.find()) { String replacement = treateWord(m.group()); if(!useGroupName){ // 不用groupname的话这里需转义 replacement = replacement.replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\"); } m.appendReplacement(sb, replacement); } m.appendTail(sb); return sb.toString(); } } ","date":"2016-05-28","objectID":"/2016/05/2016_05_28_javaregexexchange/:1:0","tags":["java"],"title":"JAVA做自定义正则替换","uri":"/2016/05/2016_05_28_javaregexexchange/"},{"categories":["技术"],"content":"1.2. 举例实现 　继承自AbstractExtReplace，可实现自定义替换 package util.extregex; /** * 本类是将字符串中的大写字母转换为下划线加小写字母的形式 eg. myName 转为 my_name * @author wjh * */ public class LowerMethExtReplace extends AbstractExtReplace { /** * 将字符串中的大写字母转换为下划线加小写字母的形式 eg. myName 转为 my_name */ public LowerMethExtReplace() { setRegexstr(\"[A-Z]\"); } @Override protected String treateWord(String word) { return \"_\" + word.toLowerCase(); } } ","date":"2016-05-28","objectID":"/2016/05/2016_05_28_javaregexexchange/:2:0","tags":["java"],"title":"JAVA做自定义正则替换","uri":"/2016/05/2016_05_28_javaregexexchange/"},{"categories":["技术"],"content":"1.3. 测试 package main; import util.extregex.LowerMethExtReplace; public class Main { public static void main(String[] args) { AbstractExtReplace lowerMeth = new LowerMethExtReplace(); String result = lowerMeth.extReplace(\"userName myValue\"); System.out.println(result); // 输出 user_name my_vamlue } } 2. 说明 　我们可以先看一下java的源码 String的replaceall方法： public String replaceAll(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceAll(replacement); } 　可以看出String内用的replaceall就是用的Matcher中的replaceall Matcher中的replaceall： public String replaceAll(String replacement) { reset(); boolean result = find(); if (result) { StringBuffer sb = new StringBuffer(); do { appendReplacement(sb, replacement); result = find(); } while (result); appendTail(sb); return sb.toString(); } return text.toString(); } 　本文上面的方法其实就是扩展自这个方法。原方法中每次循环都默认赋值replacement，我们只需要把每次的赋值改成我们需要的即可，而正则查出的内容又都在matcher中，我们只需要把matcher中的数据作为appendReplacement的参数即可。 可以大概过一下appendReplacement方法。中间大部分的都是在处理groupname，等会儿会在后面写几个示例： public Matcher appendReplacement(StringBuffer sb, String replacement) { // If no match, return error if (first \u003c 0) throw new IllegalStateException(\"No match available\"); // Process substitution string to replace group references with groups int cursor = 0; StringBuilder result = new StringBuilder(); while (cursor \u003c replacement.length()) { char nextChar = replacement.charAt(cursor); if (nextChar == '\\\\') { cursor++; if (cursor == replacement.length()) throw new IllegalArgumentException( \"character to be escaped is missing\"); nextChar = replacement.charAt(cursor); result.append(nextChar); cursor++; } else if (nextChar == '$') { // Skip past $ cursor++; // Throw IAE if this \"$\" is the last character in replacement if (cursor == replacement.length()) throw new IllegalArgumentException( \"Illegal group reference: group index is missing\"); nextChar = replacement.charAt(cursor); int refNum = -1; if (nextChar == '{') { cursor++; StringBuilder gsb = new StringBuilder(); while (cursor \u003c replacement.length()) { nextChar = replacement.charAt(cursor); if (ASCII.isLower(nextChar) || ASCII.isUpper(nextChar) || ASCII.isDigit(nextChar)) { gsb.append(nextChar); cursor++; } else { break; } } if (gsb.length() == 0) throw new IllegalArgumentException( \"named capturing group has 0 length name\"); if (nextChar != '}') throw new IllegalArgumentException( \"named capturing group is missing trailing '}'\"); String gname = gsb.toString(); if (ASCII.isDigit(gname.charAt(0))) throw new IllegalArgumentException( \"capturing group name {\" + gname + \"} starts with digit character\"); if (!parentPattern.namedGroups().containsKey(gname)) throw new IllegalArgumentException( \"No group with name {\" + gname + \"}\"); refNum = parentPattern.namedGroups().get(gname); cursor++; } else { // The first number is always a group refNum = (int)nextChar - '0'; if ((refNum \u003c 0)||(refNum \u003e 9)) throw new IllegalArgumentException( \"Illegal group reference\"); cursor++; // Capture the largest legal group string boolean done = false; while (!done) { if (cursor \u003e= replacement.length()) { break; } int nextDigit = replacement.charAt(cursor) - '0'; if ((nextDigit \u003c 0)||(nextDigit \u003e 9)) { // not a number break; } int newRefNum = (refNum * 10) + nextDigit; if (groupCount() \u003c newRefNum) { done = true; } else { refNum = newRefNum; cursor++; } } } // Append group if (start(refNum) != -1 \u0026\u0026 end(refNum) != -1) result.append(text, start(refNum), end(refNum)); } else { result.append(nextChar); cursor++; } } // Append the intervening text sb.append(text, lastAppendPosition, first); // Append the match substitution sb.append(result); lastAppendPosition = last; return this; } 　我们可以看到java对groupname做了一些处理，如有$字符或\\字符的话需要转义，这也是我在封装抽象类时添加了一个useGroupname参数的原因。这里的转义很有意思，共进行了2次转义。java中一次，替换时一次，也就是说如果准备替换成的字符串有两个反斜杠，那转义后就应该是4个反斜杠，如果写成String字符串明文表示的话还得进行一次转义，一共得写8个。 　这里的逻辑也很明显只处理了能匹配最后一个值前面的部分，后面的却还没影儿呢。现在要做的是把尾巴接上，调用它的appendTail方法。 public StringBuffer appendTail(StringBuffer sb) { sb.append(text, lastAppendPosition, getTex","date":"2016-05-28","objectID":"/2016/05/2016_05_28_javaregexexchange/:3:0","tags":["java"],"title":"JAVA做自定义正则替换","uri":"/2016/05/2016_05_28_javaregexexchange/"},{"categories":["技术"],"content":"用Golang实现红黑树算是一次尝试，毕竟工作环境没用到，不知道以后会不会用。自己也是看着玩，开阔一下思路。从我开始看Golang的doc到写这篇文章利用的是大概2周中的业余时间，所以Golang的语法掌握的还有欠缺；很多特性，例如高并发等都还没有测试，如文中出现错误或不合理的地方，请指正。 本文应用的基本逻辑参考自wiki的 红黑树，依据golang的语言特性部分结构可能稍有改动。同时这篇文章里也加入了我在实现过程中的想法和实现时可能会遇到的问题。wiki上的红黑树中文版本，不过建议直接看英文版本，不知道是翻译的原因还是版本没跟上，中文版本很多有助于理解的重要信息丢失了。而且最后附的源码我也大概看了一下，和上面解释的逻辑在细节上也稍有不同，如果看的话要注意。 由于代码比较占空间，我在文章里只说重点代码结构，完整代码在我的github上，有兴趣的可以去看一下，地址： rbtree源码 进入正题，下面我将介绍红黑树基于Golang的实现，及实现过程中我自己的理解。主要有以下内容： ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:0:0","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"1. 红黑树特点 红黑树的特点说明来自wiki，我这里简单翻译一下，括号里面的注是我自己的理解。 节点不是红色就是黑色 节点的根是黑色。这条有时会被忽略。过程中根一般由红色转为黑色，却没必要由黑色转为红色，这条规则会在分析时有一定影响（注：没明白这影响指什么……） 所有的空叶子节点都是黑色的（注：注意是空叶子节点，这个特性在插入里面用不到；在节点删除里面起作用，有点小坑，讲删除时会提到） 如果一个节点是红色，那么它的两个子节点都是黑色（注：也就是说树里面不会出父子节点都是红色的情况） 从任意一个节点到这个节点后代的每一个空叶子节点的直接路径都要经过相同个数的黑色节点。这里有几个定义：从根节点到某个节点所经过的黑色节点的数目成为这个节点的 black depth；从根节点到叶子节点的所经过的黑色节点数目成为这个树的 black-height black-height可以用来计算时间复杂度，通过性质4、5可以计算出红黑树查询的时间复杂度为 \\(O(log_2n)\\) ，这里不细证明。 再补充一点，每次插入的节点初始时都是红色，这个在添加的时候会说到，提前说一下有助于理解。 后两条是重点，当然，从这两条也能看出红黑树并不是一个完全的平衡二叉树，它的平衡在于黑色节点的平衡，上图（注：每个叶子节点都有2个空的叶子节点，文章中所有红黑树的图里面不是必要时我就不画了，显得太乱）: Figure 1. 红黑树示例 红黑树的特征就是这些，下面我们将按照这些特征利用Golang建树 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:1:0","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"2. 红黑树结构的建立 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:2:0","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"2.1. 节点结构 节点有红黑两色，我们先定义2个常量。布尔型足够： const ( // RED 红树设为true RED bool = true // BLACK 黑树设为false BLACK bool = false ) 然后是节点结构，包括树共有的特性：节点的值，指向父节点、左右儿子节点的3个指针；还有红黑树特有的：颜色。下面是树的结构： // RBNode 红黑树 type RBNode struct { value int64 color bool left, right, parent *RBNode } 还有一些查找父节点，兄弟节点的方法，很简单，就不细说了。 // getGrandParent() 获取父级节点的父级节点 func (rbnode *RBNode) getGrandParent() *RBNode {'代码略……'} // getSibling() 获取兄弟节点 func (rbnode *RBNode) getSibling() *RBNode {'代码略……'} // GetUncle() 父节点的兄弟节点 func (rbnode *RBNode) getUncle() *RBNode {'代码略……'} ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:2:1","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"2.2. 树的结构 树的结构只包含一个根节点Root，还有很多方法，等介绍插入删除时再细说，代码结构如下: type RBTree struct { root *RBNode } ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:2:2","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"2.3. 树的旋转 节点的结构里面有个方法很重要，是整个红黑树的一个核心功能，那就是树的旋转。添加和删除过程中都多次应用到了树的旋转。下面就讲一下旋转的细节。对旋转比较熟的就可以直接看下一部分了。 先定义旋转常量： const ( // 左旋 LEFTROTATE bool = true // 右旋 RIGHTROTATE bool = false ) 树的旋转包括左旋和右旋，下面图解说明 Figure 2. 左旋 左旋：以P为轴心左旋，N原来的父节点P作为N节点的左孩子，原N节点的左孩子变为P节点的右孩子，左旋就完成了。 Figure 3. 右旋 右旋：与左旋类似，只是把N节点的右孩子变为了P节点的左孩子。 节点左旋必须有右孩子，右旋必须有左孩子。 如果N经过旋转变成了根节点，一定要记得将RBTree结构体中的根节点指针root指向N，这是容易出错的地方。 旋转代码如下： // rotate() true左旋/false右旋 // 若有根节点变动则返回根节点 func (rbnode *RBNode) rotate(isRotateLeft bool) (*RBNode, error) { var root *RBNode if rbnode == nil { return root, nil } if !isRotateLeft \u0026\u0026 rbnode.left == nil { return root, errors.New(\"右旋左节点不能为空\") } else if isRotateLeft \u0026\u0026 rbnode.right == nil { return root, errors.New(\"左旋右节点不能为空\") } parent := rbnode.parent var isleft bool if parent != nil { isleft = parent.left == rbnode } if isRotateLeft { grandson := rbnode.right.left rbnode.right.left = rbnode rbnode.parent = rbnode.right rbnode.right = grandson } else { grandson := rbnode.left.right rbnode.left.right = rbnode rbnode.parent = rbnode.left rbnode.left = grandson } // 判断是否换了根节点 if parent == nil { rbnode.parent.parent = nil root = rbnode.parent } else { if isleft { parent.left = rbnode.parent } else { parent.right = rbnode.parent } rbnode.parent.parent = parent } return root, nil } ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:2:3","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"3. 节点插入 插入相对来说简单一些，首先是一个查找树的插入，然后是分治法进行树的变化以符合红黑树特征 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:3:0","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"3.1. 数据的插入 二叉查找树的插入方式，没啥好说的，直接上代码： func (rbtree *RBTree) insertNode(pnode *RBNode, data int64) { if pnode.value \u003e= data { // 插入数据不大于父节点，插入左节点 if pnode.left != nil { rbtree.insertNode(pnode.left, data) } else { tmpnode := NewRBNode(data) tmpnode.parent = pnode pnode.left = tmpnode rbtree.insertCheck(tmpnode) } } else { // 插入数据大于父节点，插入右节点 if pnode.right != nil { rbtree.insertNode(pnode.right, data) } else { tmpnode := NewRBNode(data) tmpnode.parent = pnode pnode.right = tmpnode // 插入验证 rbtree.insertCheck(tmpnode) } } } ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:3:1","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"3.2. 插入时树结构的检查及变化 检查分几种情况，下面依次说明： 要检查的节点没有父节点，意为此节点为root，则设置此节点的颜色为黑色（一开始提到过，插入时的节点初始时都是红色），直接返回，若不是根节点，则进行情况2的检查。 如果添加节点的父节点是黑色，那就省事儿多了。插入的是红色，不影响黑色数量，且由于父节点是黑色，不会出现父子节点都是红色的情况。性质4、5都不受影响。 若添加点的父节点也是红色，那就得考虑考虑了，这里应用了分治法，包括添加的节点N，N的父节点P，N的叔父节点U，N的祖父节点G。 　下一步就是根据U节点的颜色进入不同流程，G左边的节点中有相邻的2个红色节点，肯定有一个要变成黑色，相应右边也要有变成黑色的点。这样，如果U是红色，则可直接变成黑色；若本身就是黑色，那就得用旋转的方法寻找平衡了，下面先说U节点是红色的情况。 a) 若U为红色，则P与U都直接变成黑色，这样这部分每条路线上都多了一个黑色节点，需再减去一个以达到外部的平衡，然后把G改为红色。这样又会出现一个问题，那就是G的父节点的颜色未知，如果也是红色，那就又不符合规则了。又出现了要检查的内容。我们直接把这个问题扔给上一级，让上一级去解决，直到解决完成，即用递归的方式处理（N或P是左孩子还是右孩子没有关系，这里为了方便，只写出一个）。 Figure 4. 颜色改变 　b) 若U为黑色，则进入旋转平衡阶段。 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:3:2","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"3.3. 插入节点时的树的旋转情况 内容比较多，就拿出来单说了。这里是红黑树插入的重要步骤。树的旋转需注意把根节点的情况考虑进去，我们先写左旋和右旋的方法，实现如下： func (rbtree *RBTree) rotateLeft(node *RBNode) { if tmproot, err := node.rotate(LEFTROTATE); err == nil { if tmproot != nil { rbtree.root = tmproot } } else { log.Printf(err.Error()) } } 以上是左旋的实现，右旋类似，不再赘述。 下面是旋转平衡的几种情况： N是P的左（右）孩子，P同样是G的左（右）孩子，则只需以G为轴进行左（右）旋，然后把P改为黑色，G改为红色。左右黑色节点数目不变，且不影响外部的规则。 Figure 5. 旋转 N是P的右（左）孩子，而P是G的左（右）孩子 我们需以P为轴左旋（右边那种情况为右旋）。这时我们会发现树现在变成了1的情况，再用1的逻辑去处理就行了，同样这种旋转方式不会影响每个路径上的黑色节点数目，且结果顶点处的节点为黑色，不破坏外部的数据。 Figure 6. 旋转 这样，插入的情况便都考虑到了，下面是实现代码： func (rbtree *RBTree) insertNode(pnode *RBNode, data int64) { if pnode.value \u003e= data { // 插入数据不大于父节点，插入左节点 if pnode.left != nil { rbtree.insertNode(pnode.left, data) } else { tmpnode := NewRBNode(data) tmpnode.parent = pnode pnode.left = tmpnode rbtree.insertCheck(tmpnode) } } else { // 插入数据大于父节点，插入右节点 if pnode.right != nil { rbtree.insertNode(pnode.right, data) } else { tmpnode := NewRBNode(data) tmpnode.parent = pnode pnode.right = tmpnode rbtree.insertCheck(tmpnode) } } } func (rbtree *RBTree) insertCheck(node *RBNode) { if node.parent == nil { // 检查1：若插入节点没有父节点，则该节点为root rbtree.root = node // 设置根节点为black rbtree.root.color = BLACK return } // 父节点是黑色的话直接添加，红色则进行处理 if node.parent.color == RED { if node.getUncle() != nil \u0026\u0026 node.getUncle().color == RED { // 父节点及叔父节点都是红色，则转为黑色 node.parent.color = BLACK node.getUncle().color = BLACK // 祖父节点改成红色 node.getGrandParent().color = RED // 递归处理 rbtree.insertCheck(node.getGrandParent()) } else { // 父节点红色，父节点的兄弟节点不存在或为黑色 isleft := node == node.parent.left isparentleft := node.parent == node.getGrandParent().left if !isleft \u0026\u0026 isparentleft { rbtree.rotateLeft(node.parent) rbtree.rotateRight(node.parent) node.color = BLACK node.left.color = RED node.right.color = RED } else if isleft \u0026\u0026 !isparentleft { rbtree.rotateRight(node.parent) rbtree.rotateLeft(node.parent) node.color = BLACK node.left.color = RED node.right.color = RED } else if isleft \u0026\u0026 isparentleft { node.parent.color = BLACK node.getGrandParent().color = RED rbtree.rotateRight(node.getGrandParent()) } else if !isleft \u0026\u0026 !isparentleft { node.parent.color = BLACK node.getGrandParent().color = RED rbtree.rotateLeft(node.getGrandParent()) } } } } ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:3:3","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"4. 节点删除 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:4:0","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"4.1. 删除节点的转换 删除主要有3种情况 要删除的节点N没有子节点，可直接删除，然后验证平衡性 要删除的节点N有一个子节点S，则需将S的父节点设为N的父节点P，如果N是P的左儿子节点，就把P的左子节点设成S，右边同理。 要删除的节点N有2个儿子S1和S2，这样直接删除会麻烦很多。我们利用一下排序二叉树的性质，进行一下转换。过程如下： 选择右子树中的节点作替换（左右无所谓，道理是一样的，我们以替换右子树中的节点为例） 找到节点N右子树中最靠左边的非空节点M（不一定是叶子节点），将M的值复制到N，然后把要删除的节点改为M，则转换成了删除节点中包含有一个子节点（或没有子节点）的问题，例如下图中我们如果要删除5，则寻找节点7的最左侧的非空节点6，将6复制到5的位置，然后排序树仍然成立（原来的6要删除了，不考虑在内） Figure 7. 把删除2个节点转换成删除1个 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:4:1","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"4.2. 删除含单个子节点的节点 删除含单个子节点的节点也包括删除没有子节点的节点。如果要删除的节点没有子节点，为了转换方便，我们需在没有子节点的节点上加上一个临时节点，颜色为黑色，作为左孩子还是右孩子都可以。新加的节点虽然暂时破环了平衡，但是不影响旋转等操作（下面处理过程中能看出来）。最后记得删除即可。 删除含单个子节点的节点也包括几种情况： 删除的是根节点，且节点没有子节点，则直接删除，root置空。 删除的是根节点，且节点只有一个子节点，直接删除，将根节点指向子节点，并设置颜色为黑色 删除的是非根节点，又分几种情况； 要删除的节点是红色，则它的父节点与子节点（如果有的话）都是黑色，直接把子节点或空节点替换要删除节点的位置即可，不会影响黑节点的平衡 Figure 8. 删除的节点是红色 要删除的是黑色节点，但它的子节点存在且是红色，我们要做到只是用子节点替换它，然后改变子节点为黑色，使黑色平衡 Figure 9. 删除的节点是黑色 要删除的是黑色节点且子节点也是黑色，这就需要检验平衡了，检查替换后的孩子节点，下面一节会说明 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:4:2","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"4.3. 删除时树结构的检查及变化 由上一节我们能了解到需要检查平衡的是要删除的节点与它的子节点N都是黑色的情况，很大程度上简化了树的检查。 我们把替换后的节点用N表示，N是黑色。N的兄弟节点为了不和子节点弄混，我们用B表示。B的2个儿子分别用S1和S2表示。N的父节点称为P。 下面是几种情况: N是根节点，直接设成黑色，退出。（存在递归的情况，这个必须有） B是红色。由性质4和5，及N及N的原始父亲都是黑色可判断，如果B是红色，则它的父亲P是黑色，它的2个子树都是存在的且都是黑色（这点在逻辑过程中判断是否为空很重要）。 我们以N节点是P节点的左孩子为例，需要以P为轴左旋。把B作为最顶层，颜色设为黑色。P的颜色设为红色。这个单元上所有路径上的黑色节点数量不变。这里需注意，N节点的兄弟节点变成了S1。由于N的路径上还少一个黑色节点（已删除的父节点），整体平衡尚未成功，我们仍需努力，还有内部的解决办法，接着往下走。 Figure 10. B为红色时 P为黑色，B和它的2个子节点都是黑色（若子节点为空也算是黑色，由于golang的指针没有cpp那么神奇，这里需在逻辑中写明），为了维护单元内的平衡，我们需把B节点设为红色，这样内部黑色节点是平衡的，不过单元整体少了一个黑色节点。自己解决不了那就扔给上一层去解决吧，不在其位不谋其政。这里有个递归需注意。 Figure 11. PB及儿子为黑色 如果P是红色，B和它的2个子节点（或空节点）都是黑色，我们只需把P设成黑色，B设成红色即可，还记得情形1中的那种情况吗？这样就补全丢失的黑色了 Figure 12. P是红色 如果B是黑色，S1是红色，S2是黑色（N是P的左孩子的情况下）。则需以B为轴进行右旋，让B的左子树指针变空（为了统一到第6种情况处理），这时N的路径还还少一个黑色节点 Figure 13. S1是红色 大部分情况都考虑的差不多了，还有一种情况就是B节点为黑色，B节点的右孩子为红色（5形成的这种情况）。这时需要以P为轴进行左旋，然后交换P与B的颜色，即P为黑色，B未知。S2变为黑色。这样使单元内恢复平衡，且整个树的各个路径与删除前一致 Figure 14. S2是红色 树的删除分析就结束了，下面是实现代码： // 删除对外方法 func (rbtree *RBTree) Delete(data int64) { rbtree.delete_child(rbtree.root, data) } // 删除节点 func (rbtree *RBTree) delete_child(n *RBNode, data int64) bool { if data \u003c n.value { if n.left == nil { return false } return rbtree.delete_child(n.left, data) } if data \u003e n.value { if n.right == nil { return false } return rbtree.delete_child(n.right, data) } if n.right == nil || n.left == nil { // 两个都为空或其中一个为空，转为删除一个子树节点的问题 rbtree.delete_one(n) return true } //两个都不为空，转换成删除只含有一个子节点节点的问题 mostLeftChild := n.right.getLeftMostChild() tmpval := n.value n.value = mostLeftChild.value mostLeftChild.value = tmpval rbtree.delete_one(mostLeftChild) return true } // 删除只有一个子节点的节点 func (rbtree *RBTree) delete_one(n *RBNode) { var child *RBNode isadded := false if n.left == nil { child = n.right } else { child = n.left } if n.parent == nil \u0026\u0026 n.left == nil \u0026\u0026 n.right == nil { n = nil rbtree.root = n return } if n.parent == nil { n = nil child.parent = nil rbtree.root = child rbtree.root.color = BLACK return } if n.color == RED { if n == n.parent.left { n.parent.left = child } else { n.parent.right = child } if child != nil { child.parent = n.parent } n = nil return } if child != nil \u0026\u0026 child.color == RED \u0026\u0026 n.color == BLACK { if n == n.parent.left { n.parent.left = child } else { n.parent.right = child } child.parent = n.parent child.color = BLACK n = nil return } // 如果没有孩子节点，则添加一个临时孩子节点 if child == nil { child = NewRBNode(0) child.parent = n isadded = true } if n.parent.left == n { n.parent.left = child } else { n.parent.right = child } child.parent = n.parent if n.color == BLACK { if !isadded \u0026\u0026 child.color == RED { child.color = BLACK } else { rbtree.deleteCheck(child) } } // 如果孩子节点是后来加的，需删除 if isadded { if child.parent.left == child { child.parent.left = nil } else { child.parent.right = nil } child = nil } n = nil } // deleteCheck() 删除验证 func (rbtree *RBTree) deleteCheck(n *RBNode) { if n.parent == nil { n.color = BLACK return } if n.getSibling().color == RED { n.parent.color = RED n.getSibling().color = BLACK if n == n.parent.left { rbtree.rotateLeft(n.parent) } else { rbtree.rotateRight(n.parent) } } //注意：这里n的兄弟节点发生了变化，不再是原来的兄弟节点 is_parent_red := n.parent.color is_sib_red := n.getSibling().color is_sib_left_red := BLACK is_sib_right_red := BLACK if n.getSibling().left != nil { is_sib_left_red = n.getSibling().left.color } if n.getSibling().right != nil { is_sib_right_red = n.getSibling().right.color } if !is_parent_red \u0026\u0026 !is_sib_red \u0026\u0026 !is_sib_left_red \u0026\u0026 !is_sib_right_red { n.getSibling().color = RED rbtree.deleteCheck(n.parent) return } if is_parent_red \u0026\u0026 !is_sib_red \u0026\u0026 !is_sib_left_red \u0026\u0026 !is_sib_right_red { n.getSibling().color = RED n.parent.color = BLACK return } if n.getSibling().color == BLACK { if n.parent.left == n \u0026\u0026 is_sib_left_red \u0026\u0026 !is_sib_right_red { n.getSibling().color = RED n.getSibling().left.color = BLACK rbtree.rotateRight(n.getSibling()) } else if n.parent.right == n \u0026\u0026 !is_sib_left_red \u0026\u0026 is_sib_right_red { n.getSibling().color = RED n.getSibling().right.color = BLACK rbtree.rotate","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:4:3","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"},{"categories":["技术"],"content":"5. 后记 第一次这么写东西实在是没经验，也没计划好时间，本来计划是拿来练手的，原本计划一天写完，没想中途遇上各种问题，拖了将近2天才完成。不过一回生二回熟，相信如果下一次再碰到这种情况就快多了。 说实话，我写的这些里面介绍golang的很少，主要是红黑树的逻辑。在用golang实现的过程中，我也参考了一些Docker等框架源码的写法或方式。给我的感觉是这个语言很特别，单从代码结构上就能感觉出来，语法类似C语系，不过一个类型名后置就能感受到它的不同。期间也尝试着写服务，试着写过几个route，效率、负载什么的还没具体测试，不过从构建方式上就能感觉到它确实很方便。用不用先放在一边，看一看还是有好处的。 ","date":"2016-05-15","objectID":"/2016/05/2016_05_15_golangrbtree/:5:0","tags":["golang","index"],"title":"GoLang实现红黑树","uri":"/2016/05/2016_05_15_golangrbtree/"}]